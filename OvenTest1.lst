                  2   $LIST
0000              4   
0000              5   CLK           EQU 33333333 ; Microcontroller system crystal frequency in Hz
0000              6   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000              7   TIMER0_RELOAD EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 is always 12 unlike the N76E003 where is selectable.
0000              8   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000              9   TIMER2_RELOAD EQU ((65536-(CLK/(12*TIMER2_RATE))))
0000             10   BAND          EQU 3 ;for flat states
0000             11   LEAD          EQU 10 ;for ramp sates
0000             12   
0000             13   BAUD   EQU 57600
0000             14   T1_LOAD EQU 256-(2*CLK) / (32*12*BAUD) ;Load 253 so it counts 3 counts before overflowing, which gives us a 57600 baud rate with a 33.333MHz clock
0000             15   
0000             16   
0000             17   ; ********* Buttons ***********
0000             18   SELECT_BUTTON equ KEY_1
0000             19   RESET_BUTTON  equ KEY_0
0000             20   START_BUTTON  equ KEY_3
0000             21   STOP_BUTTON   equ KEY_2
0000             22   ;EXTRA_BUTTON  equ P4_6
0000             23   
0000             24   OVEN_PIN      equ P0.0
0000             25   SOUND_OUT     equ P1.5 ; Speaker attached to this pin
0000             26   UPDOWN        equ SWA.0
0000             27   INC_TENS      equ SWA.1
0000             28   
0000             29   ; Reset vector
0000             30   org 0x0000
0000 0205E9      31       ljmp main
0003             32   
0003             33   ; External interrupt 0 vector (not used in this code)
0003             34   org 0x0003
0003 32          35            reti
0004             36   
0004             37   ; Timer/Counter 0 overflow interrupt vector
000B             38   org 0x000B
000B 020499      39            ljmp Timer0_ISR
000E             40   
000E             41   ; External interrupt 1 vector (not used in this code)
0013             42   org 0x0013
0013 32          43            reti
0014             44   
0014             45   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             46   org 0x001B
001B 32          47            reti
001C             48   
001C             49   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             50   org 0x0023 
0023 32          51            reti
0024             52            
0024             53   ; Timer/Counter 2 overflow interrupt vector
002B             54   org 0x002B
002B 0204BB      55            ljmp Timer2_ISR
002E             56   
002E             57   
002E             58   ;--- DATA RAM ---
0030             59   dseg at 0x30
0030             60   STATE_VAR_1:     DS 1 
0031             61   STATE_VAR_2:     DS 1
0032             62   SECOND_COUNTER:  DS 1 
0033             63   TEMP_HIGH_BYTE:  DS 1 
0034             64   TEMP_LOW_BYTE:   DS 1 
0035             65   
0035             66   
0035             67   TEMP:            DS 2
0037             68   TIME:            DS 2
0039             69   POWER:           DS 2
003B             70   DEGREES60:       DS 2
003D             71   DEGREES150:      DS 2
003F             72   DEGREES220:      DS 2
0041             73   TARGET:           DS 2
0043             74   ;*** Variables ***
0043             75   SOAK_TEMP_set:       ds 2
0045             76   SOAK_TIME_set:       ds 2
0047             77   reflow_temp_set:     ds 2
0049             78   REFLOW_TIME_set:     ds 2
004B             79   
004B             80   soak_time:       ds 2
004D             81   REFLOW_TIME:     ds 2
004F             82   
004F             83   beep_count:      ds 1
0050             84   
0050             85   ; PWM variables
0050             86   LOW_LIMIT:  ds 2
0052             87   HIGH_LIMIT: ds 2
0054             88   THRESHOLD:  ds 2
0056             89   
0056             90   x:               ds      4 ;used for 32 bit math for temperature conversion
005A             91   y:               ds      4 ;used for 32 bit math for temperature conversion
005E             92   bcd:    ds  5 ; <--- ADD THIS: math32 needs 5 bytes for BCD conversions
0063             93   
0063             94   ;--ISR RELATED--;
0063             95   Count1ms:     ds 2 ; Used to determine when half second has passed
0065             96   BCD_counter:  ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
0066             97   
0066             98   
0000             99   bseg
0000            100   START_FLAG:         DBIT 1  ; Use DBIT for single bits in bseg
0001            101   half_seconds_flag:  DBIT 1  ; half second flag
0002            102   SECONDS_FLAG:       DBIT 1  ; can change later depending on how fast we want it
0003            103   SELECT_BUTTON_FLAG: DBIT 1
0004            104   mf:     dbit 1 ; <--- ADD THIS: math32 uses this as a status flag
0005            105   
002E            106   cseg
002E            107   ; These 'equ' must match the hardware wiring
002E            108   ; None of these are implemented yet, we need to match these assignments to the wiring
002E            109   ELCD_RS equ P1.7
002E            110   ;LCD_RW equ PX.X ; Not used in this code, connect the pin to GND
002E            111   ELCD_E equ  P1.1
002E            112   ELCD_D4 equ P0.7
002E            113   ELCD_D5 equ P0.5
002E            114   ELCD_D6 equ P0.3
002E            115   ELCD_D7 equ P0.1
002E            116   
002E            117   ;Keypad pin assignments
002E            118   ROW1 EQU P1.2
002E            119   ROW2 EQU P1.4
002E            120   ROW3 EQU P1.6
002E            121   ROw4 EQU P2.0
002E            122   COL1 EQU P2.2
002E            123   COL2 EQU P2.4
002E            124   COL3 EQU P2.6
002E            125   COL4 EQU P3.0
002E            126   
002E            127   ;                           1234567890123456
002E 536F616B   128   soak_temp_message:      db 'Soak Temp: xxx C', 0
     2054656D
     703A2078
     78782043
     00
003F 536F616B   129   soak_time_message:      db 'Soak Time: xxx C', 0
     2054696D
     653A2078
     78782043
     00
0050 5265666C   130   reflow_temp_message:    db 'Reflow Temp: xxs', 0
     6F772054
     656D703A
     20787873
     00
0061 5265666C   131   reflow_time_message:    db 'Reflow Time: xxs', 0
     6F772054
     696D653A
     20787873
     00
0072 52656164   132   ready_message:          db 'Ready to Start! ', 0
     7920746F
     20537461
     72742120
     00
0083            133   
                135   	$LIST
013A            137   
                614   $LIST
                140   $LIST
042C            142   
042C            143   ;-----------------------INTIALIZE SERIAL PORT FOR INPUT OUTUUT-----------------------;
042C            144   ;--Setting baud rate to 57600 with 33.33MHz clock--;
042C            145   ;-----------EXPLANATION------------
042C            146   ;Crystal oscillates at 33.33Mhz, the CV-8052 has a fixed prescaler of 12 for timers
042C            147   ;So the effective clock for timers is 33.33MHz/12 = 2.7775MHzl
042C            148   ;SMOD is set to 1 in PCON so using 1/16th the clock for baud rate generation
042C            149   ;That means the baud rate clock is 2.7775MHz/16 = 173.611kHz
042C            150   ;Since we have 253 out of 256 its three clicks 
042C            151   ;per bit, the baud rate is 173.611kHz/3 = 57.870kbps which is close enough to 57600bps
042C            152   ;-----------------------------------
042C            153   
042C            154   InitSerialPort:
042C            155            ; Configure serial port and baud rate
042C C28E       156       clr TR1 ; Disable timer 1
042E E589       157       mov a, TMOD
0430 540F       158       anl a, #0x0f ; Clear the bits for timer 1
0432 4420       159       orl a, #0x20 ; Configure timer 1 as 8-bit autoreload
0434 F589       160       mov TMOD, a ; Set timer 1 mode
0436            161   
0436 758DFD     162       mov TH1, #T1_LOAD ; Load the timer value for the desired baud rate
0439 758BFD     163       mov TL1, #T1_LOAD ;Doesnt matter what we load in TL1 because it is in autoreload mode, but we need to load it with something to prevent it from overflowing immediately
043C            164       ;Leave it as you found it, make SMOD = 1 for double baud rate
043C E587       165       mov a, PCON ; Set SMOD to 1
043E 4480       166       orl a, #0x80
0440 F587       167       mov PCON, a
0442 D28E       168       setb TR1 ; Enable timer 1
0444 759852     169       mov SCON, #01010010B ; Mode 1, 8-bit UART, enable receiver
0447 22         170            ret
0448            171   
0448            172   
0448            173   ; Transfer readings data to the accumulator and serial output
0448            174   SendSerial:
0448 853556     175       mov x+0, TEMP+0 ; reloads the temp into x which will be converted to bcd
044B 853657     176       mov x+1, TEMP+1
044E 755800     177       mov x+2, #0
0451 755900     178       mov x+3, #0
0454 12013A     179       lcall hex2bcd ; standard math32.asm function
0457            180   
0457 E55F       181       mov a, bcd+1 ; stores hundreds position in accumulator
0459 540F       182       anl a, #0x0F ; and operator to zero out first byte which is thousands( Has no value for our readings to ~250)
045B 2430       183       add a, #0x30 ; 3 is the ascii operator code for serial print
045D 12047E     184       lcall putchar
0460            185   
0460 E55E       186       mov a, bcd+0 ; first two bytes that are in bcd
0462 C4         187       swap a  ; because bcd is packed in two bytes, we must put the upper one in the lower to print
0463 540F       188       anl a, #0x0F
0465 2430       189       add a, #0x30
0467 12047E     190       lcall putchar
046A            191   
046A E55E       192       mov a, bcd+0 ; no swap needed given the ones place is in the first byte
046C 540F       193       anl a, #0x0F
046E 2430       194       add a, #0x30
0470 12047E     195       lcall putchar
0473            196   
0473 740D       197       mov a, #'\r'    ; Call both return and newline to avoid terminal view errors
0475 12047E     198       lcall putchar
0478            199   
0478 740A       200       mov a, #'\n'
047A 12047E     201       lcall putchar
047D 22         202       ret
047E            203   
047E            204   
047E            205   
047E            206   
047E            207   ; Function to stransmit accumulator value into the serial buffer register after previous completion
047E            208   putchar:
047E 3099FD     209       jnb TI, putchar ; TI is the transmit interrupt, it will loop until it is high and we know the previous bit is sent
0481            210       
0481 C299       211       clr TI  ; Reset back to 0 to indicate we are transmitting 
0483 F599       212       mov SBUF, a ; accumulator will have output chharacter already stored on it
0485 22         213       ret
0486            214   
0486            215   
0486            216   ; ******************************* TIMER ISRS ************************************
0486            217   
0486            218   Timer0_Init:
0486 E589       219            mov a, TMOD
0488 54F0       220            anl a, #0xf0 ; Clear the bits for timer 0
048A 4401       221            orl a, #0x01 ; Configure timer 0 as 16-timer
048C F589       222            mov TMOD, a
048E 758CFD     223            mov TH0, #high(TIMER0_RELOAD)
0491 758A5A     224            mov TL0, #low(TIMER0_RELOAD)
0494            225            ; Enable the timer and interrupts
0494 D2A9       226       setb ET0  ; Enable timer 0 interrupt
0496 D28C       227       setb TR0  ; Start timer 0
0498 22         228            ret
0499            229   
0499            230   ;---------------------------------;
0499            231   ; ISR for timer 0.  Set to execute;
0499            232   ; every 1/4096Hz to generate a    ;
0499            233   ; 2048 Hz square wave at pin P3.7 ;
0499            234   ;---------------------------------;
0499            235   Timer0_ISR:
0499            236            ;clr TF0  ; According to the data sheet this is done for us already.
0499 758CFD     237            mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
049C 758A5A     238            mov TL0, #low(TIMER0_RELOAD)
049F B295       239            cpl SOUND_OUT ; Connect speaker to P1.5
04A1 32         240            reti
04A2            241   
04A2            242   ;---------------------------------;
04A2            243   ; Routine to initialize the ISR   ;
04A2            244   ; for timer 2                     ;
04A2            245   ;---------------------------------;
04A2            246   Timer2_Init:
04A2 75C800     247            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
04A5 75CDF5     248            mov TH2, #high(TIMER2_RELOAD)
04A8 75CC27     249            mov TL2, #low(TIMER2_RELOAD)
04AB            250            ; Set the reload value
04AB 75CBF5     251            mov RCAP2H, #high(TIMER2_RELOAD)
04AE 75CA27     252            mov RCAP2L, #low(TIMER2_RELOAD)
04B1            253            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
04B1 E4         254            clr a
04B2 F563       255            mov Count1ms+0, a
04B4 F564       256            mov Count1ms+1, a
04B6            257            ; Enable the timer and interrupts
04B6 D2AD       258       setb ET2  ; Enable timer 2 interrupt
04B8 D2CA       259       setb TR2  ; Enable timer 2
04BA 22         260            ret
04BB            261   
04BB            262   ;---------------------------------;
04BB            263   ; ISR for timer 2                 ;
04BB            264   ;---------------------------------;
04BB            265   Timer2_ISR:
04BB C2CF       266            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
04BD            267            
04BD            268            ; The two registers used in the ISR must be saved in the stack
04BD C0E0       269            push acc
04BF C0D0       270            push psw
04C1            271            
04C1            272            ; Increment the 16-bit one mili second counter
04C1 0563       273            inc Count1ms+0    ; Increment the low 8-bits first
04C3 E563       274            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
04C5 7002       275            jnz Inc_Done
04C7 0564       276            inc Count1ms+1 ;increment high 8-bits if low 8-bits overflowed
04C9            277   
04C9            278   Inc_Done:
04C9            279            ; Check if full second has passed
04C9 E563       280            mov a, Count1ms+0
04CB B4E80D     281            cjne a, #low(1000), Timer2_ISR_Midpoint ; Warning: this instruction changes the carry flag!
04CE E564       282            mov a, Count1ms+1
04D0 B40308     283            cjne a, #high(1000), Timer2_ISR_Midpoint
04D3            284       
04D3            285       ;a second has passed good to convert temperature;
04D3            286       ;---------------Temperature reading and conversion function------------------;
04D3            287       ; Start ADC conversion
04D3            288   
04D3            289       
04D3            290       
04D3            291   
04D3 12054B     292       lcall Display_BCD_7_seg
04D6 120448     293       lcall SendSerial
04D9            294   
04D9 8003       295       sjmp Timer2_ISR_Bypass
04DB            296   
04DB            297   Timer2_ISR_Midpoint:
04DB 020519     298   ljmp Timer2_ISR_done
04DE            299   Timer2_ISR_Bypass:
04DE            300   
04DE            301   ;---------------------------------------------------------------------;
04DE            302            
04DE            303            ;1 second have passed.  Set a flag so the main program knows
04DE D202       304            setb seconds_flag ; Let the main program know one second had passed
04E0            305            ; Toggle LEDR0 so it blinks
04E0 0537       306       inc TIME ; Increment the TIME Variable
04E2 B2E8       307            cpl LEDRA.0
04E4 B28C       308            cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
04E6            309            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
04E6 E4         310            clr a
04E7 F563       311            mov Count1ms+0, a
04E9 F564       312            mov Count1ms+1, a
04EB            313       
04EB            314       ;Call PWM funcions
04EB            315   Checkforstate1:
04EB E530       316       MOV A, STATE_VAR_1
04ED B40105     317       CJNE A, #1, NOT_STATE_1
04F0 1205A8     318       LCALL pwm_for_ramp
04F3 8016       319       SJMP PWM_EXIT
04F5            320   NOT_STATE_1:
04F5 B40305     321       CJNE A, #3, NOT_STATE_3
04F8 1205A8     322       LCALL pwm_for_ramp
04FB 800E       323       SJMP PWM_EXIT
04FD            324   NOT_STATE_3:
04FD B40205     325       CJNE A, #2, NOT_STATE_2
0500 12057C     326       LCALL pwm_for_flatstates
0503 8006       327       SJMP PWM_EXIT
0505            328   NOT_STATE_2:
0505 B40403     329       CJNE A, #4, PWM_EXIT     ; If not 4, do nothing and exit
0508 12057C     330       LCALL pwm_for_flatstates
050B            331   PWM_EXIT:
050B            332       
050B            333            ; Increment the BCD counter
050B E565       334            mov a, BCD_counter
050D 20E804     335            jb UPDOWN, Timer2_ISR_decrement
0510 2401       336            add a, #0x01
0512 8002       337            sjmp Timer2_ISR_da
0514            338   Timer2_ISR_decrement:
0514 2499       339            add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.
0516            340   Timer2_ISR_da:
0516 D4         341            da a ; Decimal adjust instruction.  Check datasheet for more details!
0517 F565       342            mov BCD_counter, a
0519            343            
0519            344   Timer2_ISR_done:
0519 D0D0       345            pop psw
051B D0E0       346            pop acc
051D 32         347            reti
051E            348   
051E            349   INITIALIZE:
051E            350   
051E 759AAB     351            mov P0MOD, #10101011b ; P0.0(OVEN_PIN), P0.1, P0.3, P0.5, P0.7(LCD) are outputs. 
0521 759BF6     352       mov P1MOD, #11110110b ; P1.7, P1.5, P1.1(LCD), 1.2, 1.4, 1.6(ROW) are outputs
0524 759C01     353       mov P2MOD, #00000001b ; 2.0(ROW), 2.2, 2.4, 2.6(COL)
0527 759D01     354       mov P3MOD, #00000001b ; 3.0 (COL)
052A            355       ; for keypad, (ROWS as output-1)1.2, 1.4, 1.6, 2.0 - (COLS as input-0) 2.2, 2.4, 2.6, 3.0
052A 75A100     356       mov ADC_C, #0x00      ; Select ADC Channel 0
052D 22         357       ret                   ; Added RET so it doesn't crash after initializing
052E            358   
052E            359   ; ************************** FUNCTIONS ***********************************
052E            360   
052E            361   Wait50ms:
052E            362   ;33.33MHz, 1 clk per cycle: 0.03us
052E 781E       363            mov R0, #30
0530            364   Wait50ms_L3:
0530 794A       365            mov R1, #74
0532            366   Wait50ms_L2:
0532 7AFA       367            mov R2, #250
0534            368   Wait50ms_L1:
0534 DAFE       369            djnz R2, Wait50ms_L1 ;3*250*0.03us=22.5us
0536 D9FA       370       djnz R1, Wait50ms_L2 ;74*22.5us=1.665ms
0538 D8F6       371       djnz R0, Wait50ms_L3 ;1.665ms*30=50ms
053A 22         372       ret
053B            373   
053B            374   
053B            375   ; **************************** KEYPAD *******************************
053B            376   
053B            377   
053B            378   
053B            379   
053B            380   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
053B            381   T_7seg:
053B C0F9A4B0   382       DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
     99
0540 9282F880   383       DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
     90
0545 8883C6A1   384       DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F
     868E
054B            385   
054B            386   ; Displays a BCD number in HEX1-HEX0
054B            387   Display_BCD_7_Seg:
054B            388   
054B C0E0       389       push acc
054D C0D0       390       push psw
054F            391            
054F 90053B     392            mov dptr, #T_7seg
0552            393   
0552 E536       394       mov a, TEMP+1
0554 540F       395       anl a, #0FH
0556 93         396       movc a, @a+dptr
0557 F593       397       mov HEX2, a
0559            398   
0559 E535       399            mov a, TEMP
055B C4         400            swap a
055C 540F       401            anl a, #0FH
055E 93         402            movc a, @a+dptr
055F F592       403            mov HEX1, a
0561            404            
0561 E535       405            mov a, TEMP
0563 540F       406            anl a, #0FH
0565 93         407            movc a, @a+dptr
0566 F591       408            mov HEX0, a
0568            409   
0568 D0D0       410       pop psw
056A D0E0       411       pop acc
056C            412            
056C 22         413            ret
056D            414   
056D            415   
056D            416   Check_Select_Button_Press:
056D            417   
056D 20F90B     418       jb SELECT_BUTTON, Not_Pressed
0570 12052E     419       lcall Wait50ms
0573 20F905     420       jb SELECT_BUTTON, Not_Pressed
0576            421   
0576 D203       422       setb SELECT_BUTTON_FLAG
0578            423   
0578 30F9FD     424       jnb SELECT_BUTTON, $
057B            425   
057B            426       Not_Pressed:
057B            427   
057B 22         428       ret
057C            429   
057C            430   
057C            431       
057C            432       ;---------------READ KEYPAD-------------------;
057C            433       ;A Macro essentially works like CHECK_COL(COL#, Literal value coloumn represents)
057C            434       ;If the column is pressed, R7 will contain the column number (1-4)
057C            435       
057C            436   
057C            437   ;**************************PWM**************************;
057C            438   pwm_for_flatstates:
057C            439   ; ---- LOW_LIM = max(0, T_TGT - T_BAND)
057C E541       440           MOV     A, TARGET          
057E C3         441           CLR     C                 ;clear carry
057F 9403       442           SUBB    A, #BAND         ; A = A - BAND
0581 5002       443           JNC     flat_low_ok       
0583 7400       444           MOV     A, #00h           
0585            445   flat_low_ok:
0585 F550       446           MOV     LOW_LIMIT, A        ; Store low limit in RAM
0587            447   
0587            448           ;compute high limit
0587 E541       449           MOV     A, TARGET          
0589 2403       450           ADD     A, #BAND         
058B 5002       451           JNC     flat_high_ok      
058D 74FF       452           MOV     A, #0FFh          
058F            453   flat_high_ok:
058F F552       454           MOV     HIGH_LIMIT, A       
0591            455   
0591            456           ;turn oven on if curren temp is less than low limit
0591 E535       457           MOV     A, TEMP          ;make sure this variables is right!!!!!!!
0593 C3         458           CLR     C               
0594 9550       459           SUBB    A, LOW_LIMIT       
0596            460                                    
0596 400A       461           JC      flat_on       ;temp is less than low limit so turn power on since there is carry
0598            462   
0598            463           ;if current temp is greater than high lim turn off
0598 E535       464           MOV     A, TEMP
059A C3         465           CLR     C                 
059B 9552       466           SUBB    A, HIGH_LIMIT       
059D            467                                    
059D 6002       468           JZ      flat_done         ; If equal to HIGH_LIMit do nothing
059F 5004       469           JNC     flat_off      ; If no borrow and not zero T_CUR > HIGH_LIM so turn off
05A1            470   
05A1            471   flat_done:
05A1 22         472           RET                       ; Inside band do nothing, holds prev values
05A2            473   flat_on:
05A2 D280       474           SETB p0.0      ;turn power on
05A4 22         475           RET
05A5            476   
05A5            477   flat_off:
05A5 C280       478           CLR p0.0      ;power off
05A7 22         479           RET
05A8            480   
05A8            481   
05A8            482   
05A8            483   
05A8            484   pwm_for_ramp:
05A8 E541       485   MOV     A, TARGET          
05AA C3         486           CLR     C                 
05AB 940A       487           SUBB    A, #LEAD         
05AD            488                                    
05AD 5002       489           JNC     ramp_thresh_ok    
05AF 7400       490           MOV     A, #00h           
05B1            491   ramp_thresh_ok:
05B1 F554       492           MOV     THRESHOLD, A         
05B3            493   
05B3            494           ;if less than threshold turn power on 
05B3 E535       495           MOV     A, TEMP          
05B5 C3         496           CLR     C                 
05B6 9554       497           SUBB    A, THRESHOLD         ; A = curren temp - threshold(target-lead)
05B8            498                                    
05B8 4026       499           JC      ramp_force_on     ; If below threshold force on and return
05BA            500   
05BA            501           ;when close to target use deadband
05BA            502           ; LOW_LIM = max(0, T_TGT - BAND)
05BA E541       503           MOV     A, TARGET          
05BC C3         504           CLR     C                 
05BD 9403       505           SUBB    A, #BAND          
05BF 5002       506           JNC     ramp_low_ok       
05C1 7400       507           MOV     A, #00h           
05C3            508   ramp_low_ok: 
05C3 F550       509           MOV     LOW_LIMIT, A        
05C5            510   ;compute high limit
05C5 E541       511           MOV     A, TARGET          
05C7 2403       512           ADD     A, #BAND         
05C9 5002       513           JNC     ramp_high_ok      
05CB 74FF       514           MOV     A, #0FFh          
05CD            515   ramp_high_ok:
05CD F552       516           MOV     HIGH_LIMIT, A       
05CF            517   
05CF            518           ;if current temp is less than low limit turn power on 
05CF E535       519           MOV     A, TEMP          
05D1 C3         520           CLR     C                 
05D2 9550       521           SUBB    A, LOW_LIMIT        ;A = current temp - low limit (borrow if CUR < low limit)
05D4 400D       522           JC      ramp_set_on       ; If below low limit, turn ON
05D6            523   
05D6            524           ;else turn off
05D6 E535       525           MOV     A, TEMP          
05D8 C3         526           CLR     C                 
05D9 9552       527           SUBB    A, HIGH_LIMIT       
05DB 6002       528           JZ      ramp_done         ; If equal to HIGH_LIM, inside band do nothing
05DD 5007       529           JNC     ramp_set_off      ; If no borrow and not zero, above high limit set OFF
05DF            530   
05DF            531   ramp_done:
05DF 22         532           RET                      
05E0            533   
05E0            534   ramp_force_on:
05E0 D280       535           SETB p0.0      ;power on
05E2 22         536           RET
05E3            537   
05E3            538   ramp_set_on:
05E3 D280       539           SETB p0.0
05E5 22         540           RET
05E6            541   
05E6            542   ramp_set_off:
05E6 C280       543           CLR p0.0
05E8 22         544           RET 
05E9            545   
05E9            546   ;--- MAIN PROGRAM START ---
05E9            547   MAIN:
05E9 75817F     548       mov SP, #0x7F         ; Initialize Stack Pointer (Good practice)
05EC 12051E     549       lcall INITIALIZE      ; intialize pins and adc, for now
05EF            550   
05EF 120486     551       lcall Timer0_Init
05F2 1204A2     552       lcall Timer2_Init
05F5 D2AF       553       setB EA ; Enable global interrupts
05F7 1200DF     554       lcall ELCD_4BIT ; Intialize LCD
05FA 12042C     555       lcall InitSerialPort
05FD            556       
05FD C202       557       clr seconds_flag
05FF C200       558       clr START_FLAG
0601            559   
0601 754396     560       mov soak_temp_set, #150
0604 75453C     561       mov soak_time_set, #60
0607 7547DC     562       mov reflow_temp_set, #220
060A 75491E     563       mov reflow_time_set, #30
060D            564   
060D 753000     565       mov STATE_VAR_1, #0x0000
0610 753100     566       mov STATE_VAR_2, #0x0000
0613 753700     567       mov TIME, #0
0616 75351E     568       mov TEMP, #0030
0619 753900     569       mov POWER, #0
061C 753B3C     570       mov DEGREES60, #60
061F 753D96     571       mov DEGREES150, #150
0622 753FDC     572       mov DEGREES220, #220
0625 754100     573       mov TARGET,       #0
0628            574   
0628 755E00     575       mov bcd, #0x0000
062B            576   
062B            577   MAIN_LOOP:
062B            578   
062B            579   PARAM_FSM:
062B            580   
062B            581   
062B            582   ; **************************** FSM for selecting parameters *************************
062B            583   ; 4 main states ->  A: select soak temp
062B            584   ;                   B: select soak time
062B            585   ;                   C: select reflow temp
062B            586   ;                   D: select reflow time
062B            587   ;
062B            588   ; move to other FSM when start button turns on start flag
062B            589   
062B            590   StateAInit:
062B C0E0       591            push acc
062D 7401       591            mov a, #1
062F 14         591            dec a
0630 12011F     591            lcall ?Set_Cursor_1 ; Select column and row
0633 D0E0       591            pop acc
0635 C083       592            push dph
0637 C082       592            push dpl
0639 C0E0       592            push acc
063B 90002E     592            mov dptr, #soak_temp_message
063E 120112     592            lcall ?Send_Constant_String
0641 D0E0       592            pop acc
0643 D082       592            pop dpl
0645 D083       592            pop dph
0647            593   StateA:
0647 E531       594       mov a, STATE_VAR_2
0649            595   
0649 B40030     596       cjne a, #0, StateBInit
064C 12056D     597       lcall Check_Select_Button_Press
064F 20031E     598       jb SELECT_BUTTON_FLAG, StateADone
0652            599       
0652            600       ;lcall Keypad
0652            601       ;jnc StateA
0652            602   
0652            603       ;lcall Shift_Digits_Left
0652            604       
0652 C0E0       605            push acc
0654 740C       605            mov a, #12
0656 14         605            dec a
0657 12011F     605            lcall ?Set_Cursor_1 ; Select column and row
065A D0E0       605            pop acc
065C C000       606            push ar0
065E A85F       606            mov r0, bcd+1
0660 120124     606            lcall ?Display_BCD
0663 D000       606            pop ar0
0665 C000       607            push ar0
0667 A85E       607            mov r0, bcd+0
0669 120124     607            lcall ?Display_BCD
066C D000       607            pop ar0
066E            608   
066E 80D7       609       sjmp StateA
0670            610   StateADone:
0670 855E43     611       mov soak_temp_set+0, bcd+0
0673 855F44     612       mov soak_temp_set+1, bcd+1
0676 0531       613       inc STATE_VAR_2
0678 C203       614       clr SELECT_BUTTON_FLAG
067A 80CB       615       sjmp StateA
067C            616   
067C            617   StateBInit:
067C C0E0       618            push acc
067E 7401       618            mov a, #1
0680 14         618            dec a
0681 12011F     618            lcall ?Set_Cursor_1 ; Select column and row
0684 D0E0       618            pop acc
0686 C083       619            push dph
0688 C082       619            push dpl
068A C0E0       619            push acc
068C 90003F     619            mov dptr, #soak_time_message
068F 120112     619            lcall ?Send_Constant_String
0692 D0E0       619            pop acc
0694 D082       619            pop dpl
0696 D083       619            pop dph
0698            620   StateB:
0698 E531       621       mov a, STATE_VAR_2
069A            622   
069A B40130     623       cjne a, #1, StateCInit
069D 12056D     624       lcall Check_Select_Button_Press
06A0 20031E     625       jb SELECT_BUTTON_FLAG, StateBDone
06A3            626       
06A3            627       ;lcall Keypad
06A3            628       ;jnc StateB
06A3            629   
06A3            630       ;lcall Shift_Digits_Left
06A3            631       
06A3 C0E0       632            push acc
06A5 740C       632            mov a, #12
06A7 14         632            dec a
06A8 12011F     632            lcall ?Set_Cursor_1 ; Select column and row
06AB D0E0       632            pop acc
06AD C000       633            push ar0
06AF A85F       633            mov r0, bcd+1
06B1 120124     633            lcall ?Display_BCD
06B4 D000       633            pop ar0
06B6 C000       634            push ar0
06B8 A85E       634            mov r0, bcd+0
06BA 120124     634            lcall ?Display_BCD
06BD D000       634            pop ar0
06BF            635       
06BF 80D7       636       sjmp StateB
06C1            637   StateBDone:
06C1 855E45     638       mov soak_time_set+0, bcd+0
06C4 855F46     639       mov soak_time_set+1, bcd+1
06C7 0531       640       inc STATE_VAR_2
06C9 C203       641       clr SELECT_BUTTON_FLAG
06CB 80CB       642       sjmp StateB
06CD            643   
06CD            644   StateCInit:
06CD C0E0       645            push acc
06CF 7401       645            mov a, #1
06D1 14         645            dec a
06D2 12011F     645            lcall ?Set_Cursor_1 ; Select column and row
06D5 D0E0       645            pop acc
06D7 C083       646            push dph
06D9 C082       646            push dpl
06DB C0E0       646            push acc
06DD 900050     646            mov dptr, #reflow_temp_message
06E0 120112     646            lcall ?Send_Constant_String
06E3 D0E0       646            pop acc
06E5 D082       646            pop dpl
06E7 D083       646            pop dph
06E9            647   StateC:
06E9 E531       648       mov a, STATE_VAR_2
06EB            649   
06EB B40230     650       cjne a, #2, StateDInit
06EE 12056D     651       lcall Check_Select_Button_Press
06F1 20031E     652       jb SELECT_BUTTON_FLAG, StateCDone
06F4            653   
06F4            654       ;lcall Keypad
06F4            655       ;jnc StateC
06F4            656   
06F4            657       ;lcall Shift_Digits_Left
06F4            658       
06F4 C0E0       659            push acc
06F6 740E       659            mov a, #14
06F8 14         659            dec a
06F9 12011F     659            lcall ?Set_Cursor_1 ; Select column and row
06FC D0E0       659            pop acc
06FE C000       660            push ar0
0700 A85F       660            mov r0, bcd+1
0702 120124     660            lcall ?Display_BCD
0705 D000       660            pop ar0
0707 C000       661            push ar0
0709 A85E       661            mov r0, bcd+0
070B 120124     661            lcall ?Display_BCD
070E D000       661            pop ar0
0710            662   
0710 80D7       663       sjmp StateC
0712            664   StateCDone:
0712 855E47     665       mov reflow_temp_set+0, bcd+0
0715 855F48     666       mov reflow_temp_set+1, bcd+1
0718 0531       667       inc STATE_VAR_2
071A C203       668       clr SELECT_BUTTON_FLAG
071C 80CB       669       sjmp StateC
071E            670   
071E            671   StateDInit:
071E C0E0       672            push acc
0720 7401       672            mov a, #1
0722 14         672            dec a
0723 12011F     672            lcall ?Set_Cursor_1 ; Select column and row
0726 D0E0       672            pop acc
0728 C083       673            push dph
072A C082       673            push dpl
072C C0E0       673            push acc
072E 900061     673            mov dptr, #reflow_time_message
0731 120112     673            lcall ?Send_Constant_String
0734 D0E0       673            pop acc
0736 D082       673            pop dpl
0738 D083       673            pop dph
073A            674   StateD:
073A E531       675       mov a, STATE_VAR_2
073C            676   
073C B40339     677       cjne a, #3, ReadyStateInit
073F 12056D     678       lcall Check_Select_Button_Press
0742 200327     679       jb SELECT_BUTTON_FLAG, StateDDone
0745            680   
0745            681       ;lcall Keypad 
0745            682       ;jnc StateD
0745            683   
0745            684       ;lcall Shift_Digits_Left
0745            685       
0745 C0E0       686            push acc
0747 740E       686            mov a, #14
0749 14         686            dec a
074A 12011F     686            lcall ?Set_Cursor_1 ; Select column and row
074D D0E0       686            pop acc
074F C000       687            push ar0
0751 A85F       687            mov r0, bcd+1
0753 120124     687            lcall ?Display_BCD
0756 D000       687            pop ar0
0758 C000       688            push ar0
075A A85E       688            mov r0, bcd+0
075C 120124     688            lcall ?Display_BCD
075F D000       688            pop ar0
0761 C000       689            push ar0
0763 A849       689            mov r0, reflow_time_set
0765 120124     689            lcall ?Display_BCD
0768 D000       689            pop ar0
076A            690   
076A 80CE       691       sjmp StateD
076C            692   
076C            693   StateDDone:
076C 855E49     694       mov reflow_time_set+0, bcd+0
076F 855F4A     695       mov reflow_time_set+1, bcd+1
0772 0531       696       inc STATE_VAR_2
0774 C203       697       clr SELECT_BUTTON_FLAG
0776 80C2       698       sjmp StateD
0778            699   
0778            700   ReadyStateInit:
0778 C0E0       701            push acc
077A 7401       701            mov a, #1
077C 14         701            dec a
077D 12011F     701            lcall ?Set_Cursor_1 ; Select column and row
0780 D0E0       701            pop acc
0782 C083       702            push dph
0784 C082       702            push dpl
0786 C0E0       702            push acc
0788 900072     702            mov dptr, #ready_message
078B 120112     702            lcall ?Send_Constant_String
078E D0E0       702            pop acc
0790 D082       702            pop dpl
0792 D083       702            pop dph
0794            703       
0794            704   ReadyState:
0794            705       ;jnb seconds_flag, skipSerial_0 *** not too sure what this does
0794            706   
0794            707   skipSerial_0:
0794 20FBFD     708       jb START_BUTTON, ReadyState
0797 12052E     709       lcall wait50ms
079A 20FBF7     710       jb START_BUTTON, ReadyState
079D            711   
079D D200       712       setb START_FLAG
079F 8000       713       sjmp State0
07A1            714   
07A1            715   
07A1            716   ;==================Reflow Profile FSM==================;
07A1            717   ;Checklist:
07A1            718   ; 1. Implement TEMP and TIME variables - DONE
07A1            719   ; 2. Implement FSM outputs - DONE
07A1            720   ; 3. Implement reset logic - DONE
07A1            721   ; 4. Implement abort condition - DONE
07A1            722   ; 5. Implement LCD Feedback for Each State - Not Complete
07A1            723   ; 6. Speaker beeps for state transitions - Not Complete
07A1            724   State0:
07A1 20FA0C     725       jb STOP_BUTTON, State0_StopReflow
07A4 C280       726       CLR p0.0 ;oven off
07A6 E530       727       mov a, STATE_VAR_1
07A8 B40012     728       cjne a, #0, State1
07AB 200005     729       jb START_FLAG, State0Done
07AE 80F1       730       sjmp State0
07B0            731   
07B0            732   State0_StopReflow:
07B0 0208AE     733   ljmp StopReflow
07B3            734   
07B3            735   State0Done:
07B3 0530       736       inc STATE_VAR_1
07B5 753964     737       mov POWER, #100
07B8 753700     738       mov TIME, #0
07BB 80E4       739       sjmp State0
07BD            740   State1:
07BD 20F814     741       jb RESET_BUTTON, State1_ResetToMain
07C0 20FA14     742       jb STOP_BUTTON, State1_StopReflow
07C3 E530       743       mov a, STATE_VAR_1
07C5 B4011F     744       cjne a, #1, State2
07C8 853D41     745       mov TARGET, DEGREES150
07CB AA35       746       mov R2, TEMP
07CD E541       747       mov a, TARGET
07CF B40208     748       cjne a, #0x02, CheckCarryState1
07D2 80E9       749       sjmp State1
07D4            750   
07D4            751   State1_ResetToMain:
07D4 0208A5     752   ljmp ResetToMain
07D7            753   
07D7            754   State1_StopReflow:
07D7 0208AE     755   ljmp StopReflow
07DA            756   
07DA            757   CheckCarryState1:
07DA 4004       758       jc GreaterThanState1
07DC 8000       759       sjmp LessThanState1
07DE            760   LessThanState1:
07DE 80DD       761       sjmp State1
07E0            762   GreaterThanState1:
07E0 0530       763       inc STATE_VAR_1
07E2 753914     764       mov POWER, #20
07E5 80D6       765       sjmp State1
07E7            766   State2:
07E7 20F811     767       jb RESET_BUTTON, State2_ResetToMain
07EA 20FA11     768       jb STOP_BUTTON, State2_StopReflow
07ED E530       769       mov a, STATE_VAR_1
07EF B4023F     770       cjne a, #2, State3
07F2 783C       771       mov R0, #60 ; 60 seconds
07F4 E537       772       mov a, TIME
07F6 B40028     773       cjne a, #0x00, CheckCarryState2 
07F9 8009       774       sjmp CheckAbortCondition ; Check if Temp. is at least 50 degrees after 60 seconds have passed
07FB            775   
07FB            776   State2_ResetToMain:
07FB 0208A5     777   ljmp ResetToMain
07FE            778   
07FE            779   State2_StopReflow:
07FE 0208AE     780   ljmp StopReflow
0801            781   
0801            782   State2_StopOven:
0801 0208B1     783   ljmp STOPOVEN
0804            784   
0804            785   CheckAbortCondition:
0804 7932       786       mov R1, #50
0806 E535       787       mov a, TEMP
0808 B4010A     788       cjne a, #0x01, CheckAbortCarry
080B            789       ; TEMP == 50, good enough to proceed
080B 0530       790       inc STATE_VAR_1
080D 753964     791       mov POWER, #100       ; Set State3 power
0810 753700     792       mov TIME, #0          ; Reset timer for State3
0813 801C       793       sjmp State3
0815            794   CheckAbortCarry:
0815 40EA       795       jc State2_StopOven          
0817            796       ; TEMP > 50, definitely good to proceed
0817 0530       797       inc STATE_VAR_1
0819 753964     798       mov POWER, #100
081C 753700     799       mov TIME, #0
081F 8010       800       sjmp State3
0821            801   CheckCarryState2:
0821 4002       802       jc LessThanState2
0823 8002       803       sjmp GreaterThanState2
0825            804   LessThanState2:
0825 80C0       805       sjmp State2
0827            806   GreaterThanState2:
0827 0530       807       inc STATE_VAR_1
0829 753964     808       mov POWER, #100
082C 753700     809       mov TIME, #0
082F 80B6       810       sjmp State2
0831            811   State3:
0831 20F814     812       jb RESET_BUTTON, State3_ResetToMain
0834 20FA14     813       jb STOP_BUTTON, State3_StopReflow
0837 E530       814       mov a, STATE_VAR_1
0839 B4031F     815       cjne a, #3, State4
083C 853F41     816       mov TARGET, DEGREES220
083F AA35       817       mov R2, TEMP
0841 E541       818       mov a, TARGET
0843 B40208     819       cjne a, #0x02, CheckCarryState3
0846 80E9       820       sjmp State3    
0848            821   
0848            822   State3_ResetToMain:
0848 0208A5     823   ljmp ResetToMain
084B            824   
084B            825   State3_StopReflow:
084B 0208AE     826   ljmp StopReflow
084E            827   
084E            828   CheckCarryState3:
084E 4004       829       jc GreaterThanState3
0850 8000       830       sjmp LessThanState3
0852            831   LessThanState3:
0852 80DD       832       sjmp State3
0854            833   GreaterThanState3:
0854 0530       834       inc STATE_VAR_1
0856 753914     835       mov POWER, #20
0859 80D6       836       sjmp State3
085B            837   State4:
085B 20F847     838       jb RESET_BUTTON, ResetToMain
085E 20FA4D     839       jb STOP_BUTTON, StopReflow
0861 E530       840       mov a, STATE_VAR_1
0863 B40416     841       cjne a, #4, State5
0866 782D       842       mov R0, #45 ; 45 Seconds
0868 E537       843       mov a, TIME
086A B40002     844       cjne a, #0x00, CheckCarryState4
086D 80EC       845       sjmp State4
086F            846   CheckCarryState4:
086F 4002       847       jc LessThanState4
0871 8002       848       sjmp GreaterThanState4
0873            849   LessThanState4:
0873 80E6       850       sjmp State4 
0875            851   GreaterThanState4:
0875 0530       852       inc STATE_VAR_1
0877 753900     853       mov POWER, #0
087A 80DF       854       sjmp State4
087C            855   State5:
087C 20F826     856       jb RESET_BUTTON, ResetToMain
087F 20FA2C     857       jb STOP_BUTTON, StopReflow
0882 C280       858       CLR p0.0 ;turn oven off
0884 E530       859       mov a, STATE_VAR_1    
0886 B4050C     860       cjne a, #5, State5toState0
0889 853B41     861       mov TARGET, DEGREES60
088C AA35       862       mov R2, TEMP
088E E541       863       mov a, TARGET
0890 B40205     864       cjne a, #0x02, CheckCarryState5
0893 80E7       865       sjmp State5
0895            866       
0895            867   State5toState0:
0895 0207A1     868       ljmp State0
0898            869   
0898            870   CheckCarryState5:
0898 4009       871       jc GreaterThanState5
089A 8000       872       sjmp LessThanState5
089C            873   LessThanState5:
089C 753000     874       mov STATE_VAR_1, #0
089F C200       875       clr START_FLAG
08A1 80D9       876       sjmp State5
08A3            877   GreaterThanState5:
08A3 80D7       878       sjmp State5
08A5            879   
08A5            880   ResetToMain:
08A5 753000     881       mov STATE_VAR_1, #0
08A8 753900     882       mov POWER, #0
08AB 0205E9     883       ljmp MAIN
08AE            884   
08AE            885   StopReflow:
08AE 0205E9     886       ljmp MAIN
08B1            887   
08B1            888   STOPOVEN:
08B1 20F802     889       jb RESET_BUTTON, RestartProcess
08B4 80FB       890       sjmp STOPOVEN ; Infinite loop to stop the oven if abort condition is met
08B6            891   
08B6            892   RestartProcess:
08B6 0205E9     893       ljmp MAIN
08B9            894   EN
