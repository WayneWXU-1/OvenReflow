                  2   $LIST
0000              4   
0000              5   CLK           EQU 33333333 ; Microcontroller system crystal frequency in Hz
0000              6   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000              7   TIMER0_RELOAD EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 is always 12 unlike the N76E003 where is selectable.
0000              8   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000              9   TIMER2_RELOAD EQU ((65536-(CLK/(12*TIMER2_RATE))))
0000             10   BAND          EQU 2 ;for flat states
0000             11   
0000             12   WINDOW      EQU 6     ; burst window length in seconds 
0000             13   
0000             14   BAUD   EQU 57600
0000             15   T1_LOAD EQU 256-(2*CLK) / (32*12*BAUD) ;Load 253 so it counts 3 counts before overflowing, which gives us a 57600 baud rate with a 33.333MHz clock
0000             16   
0000             17   
0000             18   ; ********* Buttons ***********
0000             19   SELECT_BUTTON equ P3_4 ; middle
0000             20   RESET_BUTTON  equ P3_2 ; left
0000             21   START_BUTTON  equ P3_5 ; middle right
0000             22   STOP_BUTTON   equ P3_7 ; right 
0000             23   PARAM_BUTTON  equ P3_3 ; middle left
0000             24   
0000             25   OVEN_PIN      equ P0_0
0000             26   SOUND_OUT     equ P1_5 ; Speaker attached to this pin
0000             27   UPDOWN        equ SWA_0
0000             28   TENS          equ SWA_1
0000             29   PRESET1       equ SWA_9
0000             30   PRESET2       equ SWA_8
0000             31   PRESET3       equ SWA_7
0000             32   PRESET4       equ SWA_6
0000             33   RED_LED       equ P1_0
0000             34   GREEN_LED     equ P3_1
0000             35   
0000             36   ; Reset vector
0000             37   org 0x0000
0000 020A32      38       ljmp MAIN
0003             39   
0003             40   ; External interrupt 0 vector (not used in this code)
0003             41   org 0x0003
0003 32          42            reti
0004             43   
0004             44   ; Timer/Counter 0 overflow interrupt vector
000B             45   org 0x000B
000B 02059D      46            ljmp Timer0_ISR
000E             47   
000E             48   ; External interrupt 1 vector (not used in this code)
0013             49   org 0x0013
0013 32          50            reti
0014             51   
0014             52   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             53   org 0x001B
001B 32          54            reti
001C             55   
001C             56   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             57   org 0x0023 
0023 32          58            reti
0024             59            
0024             60   ; Timer/Counter 2 overflow interrupt vector
002B             61   org 0x002B
002B 0205BF      62            ljmp Timer2_ISR
002E             63   
002E             64   
002E             65   ;--- DATA RAM ---
0030             66   dseg at 0x30
0030             67   STATE_VAR_1:     DS 1 
0031             68   STATE_VAR_2:     DS 1
0032             69   SECOND_COUNTER:  DS 1 
0033             70   TEMP_HIGH_BYTE:  DS 1 
0034             71   TEMP_LOW_BYTE:   DS 1 
0035             72   
0035             73   
0035             74   TEMP:            DS 5
003A             75   TIME:            DS 2
003C             76   POWER:           DS 2
003E             77   DEGREES60:       DS 2
0040             78   DEGREES150:      DS 2
0042             79   DEGREES220:      DS 2
0044             80   TARGET:          DS 2
0046             81   TARGET_TIME:     DS 2
0048             82   ;*** Variables ***
0048             83   SOAK_TEMP_set:       ds 2
004A             84   SOAK_TIME_set:       ds 2
004C             85   reflow_temp_set:     ds 2
004E             86   REFLOW_TIME_set:     ds 2
0050             87   
0050             88   soak_time:       ds 2
0052             89   REFLOW_TIME:     ds 2
0054             90   
0054             91   beep_count:      ds 1
0055             92   
0055             93   ; PWM variables
0055             94   LOW_LIMIT:  ds 2
0057             95   HIGH_LIMIT: ds 2
0059             96   THRESHOLD:  ds 2
005B             97   ON_SECS:     ds 1
005C             98   PHASE:       ds 1    ;counter for seconds
005D             99   LEAD:        ds 2 ;for ramp sates
005F            100   
005F            101   x:               ds      4 ;used for 32 bit math for temperature conversion
0063            102   y:               ds      4 ;used for 32 bit math for temperature conversion
0067            103   bcd:    ds  5 ; <--- ADD THIS: math32 needs 5 bytes for BCD conversions
006C            104   
006C            105   ;--ISR RELATED--;
006C            106   Count1ms:     ds 2 ; Used to determine when half second has passed
006E            107   BCD_counter:  ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
006F            108   
006F            109   
006F            110   ; **** keypad variables ****
006F            111   keypad_digit_count: ds 1
0070            112   
0000            113   bseg
0000            114   START_FLAG:         DBIT 1  ; Use DBIT for single bits in bseg
0001            115   half_seconds_flag:  DBIT 1  ; half second flag
0002            116   SECONDS_FLAG:       DBIT 1  ; can change later depending on how fast we want it
0003            117   SELECT_BUTTON_FLAG: DBIT 1
0004            118   PARAM_BUTTON_FLAG:  DBIT 1
0005            119   KEYPAD_FLAG:        DBIT 1
0006            120   mf:     dbit 1 ; <--- ADD THIS: math32 uses this as a status flag
0007            121   
002E            122   cseg
002E            123   ; These 'equ' must match the hardware wiring
002E            124   ; None of these are implemented yet, we need to match these assignments to the wiring
002E            125   ELCD_RS equ P1.7
002E            126   ;LCD_RW equ PX.X ; Not used in this code, connect the pin to GND
002E            127   ELCD_E equ  P1.1
002E            128   ELCD_D4 equ P0.7
002E            129   ELCD_D5 equ P0.5
002E            130   ELCD_D6 equ P0.3
002E            131   ELCD_D7 equ P0.1
002E            132   
002E            133   ;Keypad pin assignments
002E            134   ROW1 EQU P1.2
002E            135   ROW2 EQU P1.4
002E            136   ROW3 EQU P1.6
002E            137   ROW4 EQU P2.0
002E            138   COL1 EQU P2.2
002E            139   COL2 EQU P2.4
002E            140   COL3 EQU P2.6
002E            141   COL4 EQU P3.0
002E            142   
002E            143   ;                           1234567890123456
002E 20202020   144   blank_row:              db '                ', 0
     20202020
     20202020
     20202020
     00
003F 50726573   145   preset_message:         db 'Presets: 1 2 3 4', 0
     6574733A
     20312032
     20332034
     00
0050 53656C65   146   param_message:          db 'Select Parameter', 0
     63742050
     6172616D
     65746572
     00
0061 536F616B   147   soak_temp_message:      db 'Soak Temp: xxx C', 0
     2054656D
     703A2078
     78782043
     00
0072 536F616B   148   soak_time_message:      db 'Soak Time: xx  s', 0
     2054696D
     653A2078
     78202073
     00
0083 52666C77   149   reflow_temp_message:    db 'Rflw Temp: xxx C', 0
     2054656D
     703A2078
     78782043
     00
0094 52666C77   150   reflow_time_message:    db 'Rflw Time: xx  s', 0
     2054696D
     653A2078
     78202073
     00
00A5 52656164   151   ready_message:          db 'Ready to Start! ', 0
     7920746F
     20537461
     72742120
     00
00B6 2D2D2D2D   152   state0_message:         db '-----State0-----', 0
     2D537461
     7465302D
     2D2D2D2D
     00
00C7 2D2D2D2D   153   state1_message:         db '-----State1-----', 0
     2D537461
     7465312D
     2D2D2D2D
     00
00D8 2D2D2D2D   154   state2_message:         db '-----State2-----', 0
     2D537461
     7465322D
     2D2D2D2D
     00
00E9 2D2D2D2D   155   state3_message:         db '-----State3-----', 0
     2D537461
     7465332D
     2D2D2D2D
     00
00FA 2D2D2D2D   156   state4_message:         db '-----State4-----', 0
     2D537461
     7465342D
     2D2D2D2D
     00
010B 2D2D2D2D   157   state5_message:         db '-----State5-----', 0
     2D537461
     7465352D
     2D2D2D2D
     00
011C 2A2A2A2A   158   abortcondition_message: db '*****ABORT!*****', 0
     2A41424F
     5254212A
     2A2A2A2A
     00
012D 54494D45   159   reflow_message:         db 'TIME:XXXTEMP:XXX', 0
     3A585858
     54454D50
     3A585858
     00
013E 5265666C   160   reflowdone_message:     db 'Reflow Complete!', 0
     6F772043
     6F6D706C
     65746521
     00
014F 52535420   161   restart_message:        db 'RST 2 Bake Again', 0
     32204261
     6B652041
     6761696E
     00
0160            162   
0160 5265666C   163   stop_message:           db 'Reflow Stopped! ', 0
     6F772053
     746F7070
     65642120
     00
0171            164   
0171 54494D45   165   TimeLabel: db 'T','I','M','E',':', 0
     3A00
0177 54454D50   166   TempLabel: db 'T','E','M','P',':', 0
     3A00
017D            167   
                169   	$LIST
0234            171   
                614   $LIST
                174   $LIST
0526            176   
0526            177   ;-----------------------INTIALIZE SERIAL PORT FOR INPUT OUTUUT-----------------------;
0526            178   ;--Setting baud rate to 57600 with 33.33MHz clock--;
0526            179   ;-----------EXPLANATION------------
0526            180   ;Crystal oscillates at 33.33Mhz, the CV-8052 has a fixed prescaler of 12 for timers
0526            181   ;So the effective clock for timers is 33.33MHz/12 = 2.7775MHzl
0526            182   ;SMOD is set to 1 in PCON so using 1/16th the clock for baud rate generation
0526            183   ;That means the baud rate clock is 2.7775MHz/16 = 173.611kHz
0526            184   ;Since we have 253 out of 256 its three clicks 
0526            185   ;per bit, the baud rate is 173.611kHz/3 = 57.870kbps which is close enough to 57600bps
0526            186   ;-----------------------------------
0526            187   
0526            188   InitSerialPort:
0526            189            ; Configure serial port and baud rate
0526 C28E       190       clr TR1 ; Disable timer 1
0528 E589       191       mov a, TMOD
052A 540F       192       anl a, #0x0f ; Clear the bits for timer 1
052C 4420       193       orl a, #0x20 ; Configure timer 1 as 8-bit autoreload
052E F589       194       mov TMOD, a ; Set timer 1 mode
0530            195   
0530 758DFD     196       mov TH1, #T1_LOAD ; Load the timer value for the desired baud rate
0533 758BFD     197       mov TL1, #T1_LOAD ;Doesnt matter what we load in TL1 because it is in autoreload mode, but we need to load it with something to prevent it from overflowing immediately
0536            198       ;Leave it as you found it, make SMOD = 1 for double baud rate
0536 E587       199       mov a, PCON ; Set SMOD to 1
0538 4480       200       orl a, #0x80
053A F587       201       mov PCON, a
053C D28E       202       setb TR1 ; Enable timer 1
053E 759852     203       mov SCON, #01010010B ; Mode 1, 8-bit UART, enable receiver
0541 22         204            ret
0542            205   
0542            206   Display_Voltage_Serial:
0542 85355F     207            mov x+0, TEMP+0 ; reloads the temp into x which will be converted to bcd
0545 853660     208       mov x+1, TEMP+1
0548 756100     209       mov x+2, #0
054B 756200     210       mov x+3, #0
054E 120234     211       lcall hex2bcd ; standard math32.asm function
0551            212       
0551 7454       213            mov a, #'T'
0553 120582     214            lcall putchar
0556 743D       215            mov a, #'='
0558 120582     216            lcall putchar
055B            217            
055B E568       218            mov a, bcd+1
055D 540F       219            anl a, #0FH
055F 4430       220            orl a, #'0'
0561 120582     221            lcall putchar
0564            222   
0564 E567       223            mov a, bcd+0
0566 C4         224            swap a
0567 540F       225            anl a, #0FH
0569 4430       226            orl a, #'0'
056B 120582     227            lcall putchar
056E            228            
056E E567       229            mov a, bcd+0
0570 540F       230            anl a, #0FH
0572 4430       231            orl a, #'0'
0574 120582     232            lcall putchar
0577            233   
0577 740D       234            mov a, #'\r'
0579 120582     235            lcall putchar
057C 740A       236            mov a, #'\n'
057E 120582     237            lcall putchar
0581            238            
0581 22         239            ret
0582            240   
0582            241   
0582            242   
0582            243   ; Function to stransmit accumulator value into the serial buffer register after previous completion
0582            244   putchar:
0582 3099FD     245       jnb TI, putchar ; TI is the transmit interrupt, it will loop until it is high and we know the previous bit is sent
0585            246       
0585 C299       247       clr TI  ; Reset back to 0 to indicate we are transmitting 
0587 F599       248       mov SBUF, a ; accumulator will have output chharacter already stored on it
0589 22         249       ret
058A            250   
058A            251   
058A            252   ; ******************************* TIMER ISRS ************************************
058A            253   
058A            254   Timer0_Init:
058A E589       255            mov a, TMOD
058C 54F0       256            anl a, #0xf0 ; Clear the bits for timer 0
058E 4401       257            orl a, #0x01 ; Configure timer 0 as 16-timer
0590 F589       258            mov TMOD, a
0592 758CFD     259            mov TH0, #high(TIMER0_RELOAD)
0595 758A5A     260            mov TL0, #low(TIMER0_RELOAD)
0598            261            ; Enable the timer and interrupts
0598 D2A9       262       setb ET0  ; Enable timer 0 interrupt
059A D28C       263       setb TR0  ; Start timer 0
059C 22         264            ret
059D            265   
059D            266   ;---------------------------------;
059D            267   ; ISR for timer 0.  Set to execute;
059D            268   ; every 1/4096Hz to generate a    ;
059D            269   ; 2048 Hz square wave at pin P1.5 ;
059D            270   ;---------------------------------;
059D            271   Timer0_ISR:
059D            272            ;clr TF0  ; According to the data sheet this is done for us already.
059D 758CFD     273            mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
05A0 758A5A     274            mov TL0, #low(TIMER0_RELOAD)
05A3 B295       275            cpl SOUND_OUT ; Connect speaker to P1.5
05A5 32         276            reti
05A6            277   
05A6            278   ;---------------------------------;
05A6            279   ; Routine to initialize the ISR   ;
05A6            280   ; for timer 2                     ;
05A6            281   ;---------------------------------;
05A6            282   Timer2_Init:
05A6 75C800     283            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
05A9 75CDF5     284            mov TH2, #high(TIMER2_RELOAD)
05AC 75CC27     285            mov TL2, #low(TIMER2_RELOAD)
05AF            286            ; Set the reload value
05AF 75CBF5     287            mov RCAP2H, #high(TIMER2_RELOAD)
05B2 75CA27     288            mov RCAP2L, #low(TIMER2_RELOAD)
05B5            289            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
05B5 E4         290            clr a
05B6 F56C       291            mov Count1ms+0, a
05B8 F56D       292            mov Count1ms+1, a
05BA            293            ; Enable the timer and interrupts
05BA D2AD       294       setb ET2  ; Enable timer 2 interrupt
05BC D2CA       295       setb TR2  ; Enable timer 2
05BE 22         296            ret
05BF            297   
05BF            298   ;---------------------------------;
05BF            299   ; ISR for timer 2                 ;
05BF            300   ;---------------------------------;
05BF            301   Timer2_ISR:
05BF C2CF       302            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
05C1            303            
05C1            304            ; The two registers used in the ISR must be saved in the stack
05C1 C0E0       305            push acc
05C3 C0D0       306            push psw
05C5            307            
05C5            308            ; Increment the 16-bit one mili second counter
05C5 056C       309            inc Count1ms+0    ; Increment the low 8-bits first
05C7 E56C       310            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
05C9 7002       311            jnz Inc_Done
05CB 056D       312            inc Count1ms+1 ;increment high 8-bits if low 8-bits overflowed
05CD            313   
05CD            314   Inc_Done:
05CD            315            ; Check if full second has passed
05CD E56C       316            mov a, Count1ms+0
05CF B4E86D     317            cjne a, #low(1000), Timer2_ISR_Midpoint ; Warning: this instruction changes the carry flag!
05D2 E56D       318            mov a, Count1ms+1
05D4 B40368     319            cjne a, #high(1000), Timer2_ISR_Midpoint
05D7            320       
05D7            321       
05D7 75A100     322            mov ADC_C, #00000000b
05DA            323            
05DA            324   
05DA 756200     325       mov x+3, #0
05DD 756100     326            mov x+2, #0
05E0 85A360     327            mov x+1, ADC_H
05E3 85A25F     328            mov x+0, ADC_L
05E6            329       ; Convert ADC reading to temperature in Celsius
05E6            330       ; Voltage = (ADC_value * 5000) / 4096
05E6 756388     331            mov y+0, #low (5000 % 0x10000) 
05E9 756413     331            mov y+1, #high(5000 % 0x10000) 
05EC 756500     331            mov y+2, #low (5000 / 0x10000) 
05EF 756600     331            mov y+3, #high(5000 / 0x10000) 
05F2            331   
05F2 120392     332            lcall mul32
05F5 756300     333            mov y+0, #low (4096 % 0x10000) 
05F8 756410     333            mov y+1, #high(4096 % 0x10000) 
05FB 756500     333            mov y+2, #low (4096 / 0x10000) 
05FE 756600     333            mov y+3, #high(4096 / 0x10000) 
0601 120486     334            lcall div32
0604            335       ; Result is in 'x'
0604            336   
0604 7563E8     337            mov y+0, #low (1000 % 0x10000) 
0607 756403     337            mov y+1, #high(1000 % 0x10000) 
060A 756500     337            mov y+2, #low (1000 / 0x10000) 
060D 756600     337            mov y+3, #high(1000 / 0x10000)  ; convert to microvolts
0610 120392     338       lcall mul32
0613 75630C     339            mov y+0, #low (12300 % 0x10000) 
0616 756430     339            mov y+1, #high(12300 % 0x10000) 
0619 756500     339            mov y+2, #low (12300 / 0x10000) 
061C 756600     339            mov y+3, #high(12300 / 0x10000)  ; 41 * 300
061F 120486     340       lcall div32
0622            341   
0622 756316     342            mov y+0, #low (22 % 0x10000) 
0625 756400     342            mov y+1, #high(22 % 0x10000) 
0628 756500     342            mov y+2, #low (22 / 0x10000) 
062B 756600     342            mov y+3, #high(22 / 0x10000)  ; add cold junction temperature
062E 1202D9     343       lcall add32
0631            344       ;do your displays and stuff
0631            345       ;result is still in x
0631 855F35     346       mov TEMP+0, x+0
0634 856036     347       mov TEMP+1, x+1
0637            348       
0637 120542     349       lcall Display_Voltage_Serial
063A 1208CD     350       lcall Display_BCD_7_seg
063D            351   
063D 8003       352       sjmp Timer2_ISR_Bypass
063F            353   
063F            354   Timer2_ISR_Midpoint:
063F 020682     355   ljmp Timer2_ISR_done
0642            356   Timer2_ISR_Bypass:
0642            357   
0642            358   ;---------------------------------------------------------------------;
0642            359            
0642            360            ;1 second have passed.  Set a flag so the main program knows
0642 D202       361            setb seconds_flag ; Let the main program know one second had passed
0644            362            ; Toggle LEDR0 so it blinks
0644 053A       363       inc TIME ; Increment the TIME Variable
0646 B2E8       364            cpl LEDRA.0
0648 E4         365            clr a
0649 F56C       366            mov Count1ms+0, a
064B F56D       367            mov Count1ms+1, a
064D            368       
064D            369       ;Call PWM funcions
064D            370   Checkforstate1:
064D E530       371       MOV A, STATE_VAR_1
064F B40105     372       CJNE A, #1, NOT_STATE_1
0652 12095F     373       LCALL RampBurstPWM
0655 8016       374       SJMP PWM_EXIT
0657            375   NOT_STATE_1:
0657 B40305     376       CJNE A, #3, NOT_STATE_3
065A 12095F     377       LCALL RampBurstPWM
065D 800E       378       SJMP PWM_EXIT
065F            379   NOT_STATE_3:
065F B40205     380       CJNE A, #2, NOT_STATE_2
0662 120933     381       LCALL pwm_for_flatstates
0665 8006       382       SJMP PWM_EXIT
0667            383   NOT_STATE_2:
0667 B40403     384       CJNE A, #4, PWM_EXIT     ; If not 4, do nothing and exit
066A 120933     385       LCALL pwm_for_flatstates
066D            386   PWM_EXIT:
066D            387   
066D            388   
066D            389       
066D            390            ; Increment the BCD counter
066D E56E       391            mov a, BCD_counter
066F 20E80B     392            jb UPDOWN, Timer2_ISR_decrement
0672 2401       393            add a, #0x01; Increment the BCD counter
0674 E56E       394            mov a, BCD_counter
0676 20E804     395            jb UPDOWN, Timer2_ISR_decrement
0679 2401       396            add a, #0x01
067B 8002       397            sjmp Timer2_ISR_da
067D            398   Timer2_ISR_decrement:
067D 2499       399            add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.
067F            400   Timer2_ISR_da:
067F D4         401            da a ; Decimal adjust instruction.  Check datasheet for more details!
0680 F56E       402            mov BCD_counter, a
0682            403   
0682            404            
0682            405   Timer2_ISR_done:
0682 D0D0       406            pop psw
0684 D0E0       407            pop acc
0686 32         408            reti
0687            409   
0687            410   INITIALIZE:
0687            411   
0687 759AAB     412            mov P0MOD, #10101011b ; P0.0(OVEN_PIN), P0.1, P0.3, P0.5, P0.7(LCD) are outputs. 
068A 759BF7     413       mov P1MOD, #11110111b ; P1.7, P1.5, P1.1(LCD), 1.2, 1.4, 1.6(ROW) are outputs, P1.0
068D 759C01     414       mov P2MOD, #00000001b ; output: 2.0(ROW) input: 2.2, 2.4, 2.6(COL)
0690 759D02     415       mov P3MOD, #00000010b ; input: 3.0 (COL), 3.2, 3.3, 3.4, 3.5, 3.7 out: 3.1
0693            416       ; for keypad, (ROWS as output-1)1.2, 1.4, 1.6, 2.0 - (COLS as input-0) 2.2, 2.4, 2.6, 3.0
0693 75A100     417       mov ADC_C, #0x00      ; Select ADC Channel 0
0696 75A180     418       mov ADC_C, #10000000b ; ADC Enable = 1 test******
0699 22         419       ret                   ; Added RET so it doesn't crash after initializing
069A            420   
069A            421   ; ************************** FUNCTIONS ***********************************
069A            422   
069A            423   Wait50ms:
069A            424   ;33.33MHz, 1 clk per cycle: 0.03us
069A 781E       425            mov R0, #30
069C            426   Wait50ms_L3:
069C 794A       427            mov R1, #74
069E            428   Wait50ms_L2:
069E 7AFA       429            mov R2, #250
06A0            430   Wait50ms_L1:
06A0 DAFE       431            djnz R2, Wait50ms_L1 ;3*250*0.03us=22.5us
06A2 D9FA       432       djnz R1, Wait50ms_L2 ;74*22.5us=1.665ms
06A4 D8F6       433       djnz R0, Wait50ms_L3 ;1.665ms*30=50ms
06A6 22         434       ret
06A7            435   
06A7            436   
06A7            437   ; **************************** KEYPAD *******************************
06A7            438   
06A7            439   myLUT:
06A7 C0F9A4B0   440       DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
     99
06AC 9282F880   441       DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
     90
06B1 8883C6A1   442       DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F
     868E
06B7            443   
                444   showBCD MAC
                445   	; Display LSD
                446       mov A, %0
                447       anl a, #0fh
                448       movc A, @A+dptr
                449       mov %1, A
                450   
                451   	; Display MSD
                452       mov A, %0
                453       swap a
                454       anl a, #0fh
                455       movc A, @A+dptr
                456       mov %2, A
                457   ENDMAC
06B7            458   
06B7            459   Display:
06B7 9006A7     460            mov dptr, #myLUT
                460   	$MESSAGE TIP: If digits 10, 9, 8, and 7 are not zero, LEDR7: on
06BA            462   
06BA E56A       463            mov a, bcd+3
06BC 456B       464            orl a, bcd+4
06BE 6004       465            jz Display_L1
06C0 D2EF       466            setb LEDRA.7 ; Non-zero digits alert
06C2 8002       467            sjmp Display_L2
06C4            468   
06C4            469   Display_L1:
06C4 C2EF       470            clr LEDRA.7
06C6            471   
06C6            472   Display_L2:
                472   	$MESSAGE TIP: Pressing KEY3, displays the most significant digits of the 10-digit number
06C6            474   
06C6 30FB2F     475            jnb key.3, Display_high_digits
06C9            476            ; Display LSD
06C9 E567       476       mov A, bcd+0
06CB 540F       476       anl a, #0fh
06CD 93         476       movc A, @A+dptr
06CE F591       476       mov HEX0, A
06D0            476   
06D0            476            ; Display MSD
06D0 E567       476       mov A, bcd+0
06D2 C4         476       swap a
06D3 540F       476       anl a, #0fh
06D5 93         476       movc A, @A+dptr
06D6 F592       476       mov HEX1, A
06D8            477            ; Display LSD
06D8 E568       477       mov A, bcd+1
06DA 540F       477       anl a, #0fh
06DC 93         477       movc A, @A+dptr
06DD F593       477       mov HEX2, A
06DF            477   
06DF            477            ; Display MSD
06DF E568       477       mov A, bcd+1
06E1 C4         477       swap a
06E2 540F       477       anl a, #0fh
06E4 93         477       movc A, @A+dptr
06E5 F594       477       mov HEX3, A
06E7            478            ; Display LSD
06E7 E569       478       mov A, bcd+2
06E9 540F       478       anl a, #0fh
06EB 93         478       movc A, @A+dptr
06EC F58E       478       mov HEX4, A
06EE            478   
06EE            478            ; Display MSD
06EE E569       478       mov A, bcd+2
06F0 C4         478       swap a
06F1 540F       478       anl a, #0fh
06F3 93         478       movc A, @A+dptr
06F4 F58F       478       mov HEX5, A
06F6            479   
06F6 8024       480            sjmp Display_end
06F8            481   
06F8            482   Display_high_digits:
06F8            483            ; Display LSD
06F8 E56A       483       mov A, bcd+3
06FA 540F       483       anl a, #0fh
06FC 93         483       movc A, @A+dptr
06FD F591       483       mov HEX0, A
06FF            483   
06FF            483            ; Display MSD
06FF E56A       483       mov A, bcd+3
0701 C4         483       swap a
0702 540F       483       anl a, #0fh
0704 93         483       movc A, @A+dptr
0705 F592       483       mov HEX1, A
0707            484            ; Display LSD
0707 E56B       484       mov A, bcd+4
0709 540F       484       anl a, #0fh
070B 93         484       movc A, @A+dptr
070C F593       484       mov HEX2, A
070E            484   
070E            484            ; Display MSD
070E E56B       484       mov A, bcd+4
0710 C4         484       swap a
0711 540F       484       anl a, #0fh
0713 93         484       movc A, @A+dptr
0714 F594       484       mov HEX3, A
0716 758EFF     485            mov HEX4, #0xff         
0719 758FFF     486            mov HEX5, #0xff         
071C            487   
071C            488   Display_end:
071C 22         489       ret
071D            490   
071D            491   
                492   MYRLC MAC
                493   	mov a, %0
                494   	rlc a
                495   	mov %0, a
                496   ENDMAC
071D            497   
071D            498   Shift_Digits_Left:
071D 7804       499            mov R0, #4 ; shift left four bits
071F            500   
071F E531       501       mov a, STATE_VAR_2
0721 B40006     502       cjne a, #0, KCheck_StateC
0724            503   
0724 E56F       504       mov a, keypad_digit_count
0726 B40310     505       cjne a, #3, Shift_Digits_Left_L0
0729            506   
0729 22         507       ret
072A            508   
072A            509   KCheck_StateC:
072A B40206     510       cjne a, #2, KCheck_Time_States
072D E56F       511       mov a, keypad_digit_count
072F B40307     512       cjne a, #3, Shift_Digits_Left_L0
0732 22         513       ret
0733            514   
0733            515   KCheck_Time_States:
0733 E56F       516       mov a, keypad_digit_count
0735 B40201     517       cjne a, #2, Shift_Digits_Left_L0
0738 22         518       ret
0739            519   
0739            520   Shift_Digits_Left_L0:
0739 C3         521            clr c
073A E567       522            mov a, bcd+0
073C 33         522            rlc a
073D F567       522            mov bcd+0, a
073F E568       523            mov a, bcd+1
0741 33         523            rlc a
0742 F568       523            mov bcd+1, a
0744 E569       524            mov a, bcd+2
0746 33         524            rlc a
0747 F569       524            mov bcd+2, a
0749 E56A       525            mov a, bcd+3
074B 33         525            rlc a
074C F56A       525            mov bcd+3, a
074E E56B       526            mov a, bcd+4
0750 33         526            rlc a
0751 F56B       526            mov bcd+4, a
0753            527   
0753 D8E4       528            djnz R0, Shift_Digits_Left_L0
0755            529            ; R7 has the new bcd digit      
0755 EF         530            mov a, R7
0756 4567       531            orl a, bcd+0
0758 F567       532            mov bcd+0, a
075A            533   
075A 056F       534       inc keypad_digit_count
075C D3         535       setb c
075D            536       
075D            537   Shift_Digits_left_exit:
075D 22         538            ret
075E            539   
075E            540            
                541   MYRRC MAC
                542   	mov a, %0
                543   	rrc a
                544   	mov %0, a
                545   ENDMAC
075E            546   
075E            547   Shift_Digits_Right:
075E 7804       548            mov R0, #4 ; shift right four bits
0760            549   
0760            550   Shift_Digits_Right_L0:
0760 C3         551            clr c
0761 E56B       552            mov a, bcd+4
0763 13         552            rrc a
0764 F56B       552            mov bcd+4, a
0766 E56A       553            mov a, bcd+3
0768 13         553            rrc a
0769 F56A       553            mov bcd+3, a
076B E569       554            mov a, bcd+2
076D 13         554            rrc a
076E F569       554            mov bcd+2, a
0770 E568       555            mov a, bcd+1
0772 13         555            rrc a
0773 F568       555            mov bcd+1, a
0775 E567       556            mov a, bcd+0
0777 13         556            rrc a
0778 F567       556            mov bcd+0, a
077A            557   
077A D8E4       558            djnz R0, Shift_Digits_Right_L0
077C            559   
077C E56F       560       mov a, keypad_digit_count
077E 6003       561       jz Shift_Digits_Right_Ret
0780 156F       562       dec keypad_digit_count
0782            563   
0782 D3         564       setb c
0783            565   
0783            566   Shift_Digits_Right_Ret:
0783 22         567            ret
0784            568   
0784            569   
0784            570   Wait25ms:
0784            571   ;33.33MHz, 1 clk per cycle: 0.03us
0784 780F       572            mov R0, #15
0786 794A       573   LL3: mov R1, #74
0788 7AFA       574   LL2: mov R2, #250
078A DAFE       575   LL1: djnz R2, LL1 ;3*250*0.03us=22.5us
078C D9FA       576        djnz R1, LL2 ;74*22.5us=1.665ms
078E D8F6       577        djnz R0, LL3 ;1.665ms*15=25ms
0790            578   
0790 22         579       ret
0791            580   
0791            581   
0791            582   
                583   CHECK_COLUMN MAC
                584   	jb %0, CHECK_COL_%M
                585   	mov R7, %1
                586   	jnb %0, $ ; wait for key release
                587   	setb c
                588   	ret
                589   CHECK_COL_%M:
                590   ENDMAC
0791            591   
0791            592   Configure_Keypad_Pins:
0791            593            ; Configure the row pins as output and the column pins as inputs
0791 439B54     594            orl P1MOD, #0b_01010100 ; P1.6, P1.4, P1.2 output
0794 439C01     595            orl P2MOD, #0b_00000001 ; P2.0 output
0797 539CAB     596            anl P2MOD, #0b_10101011 ; P2.6, P2.4, P2.2 input
079A 539DFE     597            anl P3MOD, #0b_11111110 ; P3.0 input
079D 22         598            ret
079E            599   
079E            600   ; This subroutine scans a 4x4 keypad.  If a key is pressed sets the carry
079E            601   ; to one and returns the key code in register R7.
079E            602   ; It works with both a default keypad or a modified keypad with the labels
079E            603   ; rotated 90 deg ccw.  The type of keypad is determined by SW0, which is bit SWA.0
079E            604   
079E            605   Keypad:
079E            606            ; First check the backspace/correction pushbutton.  We use KEY1 for this function.
                606   	$MESSAGE TIP: STOP_BUTTON is the erase key
079E            608   
079E 20B73F     609            jb STOP_BUTTON, keypad_L0
07A1 120784     610            lcall Wait25ms ; debounce
07A4 20B739     611            jb STOP_BUTTON, keypad_L0
07A7            612   
07A7 30B7FD     613            jnb STOP_BUTTON, $ ; The key was pressed, wait for release
07AA 12075E     614            lcall Shift_Digits_Right
07AD 120281     615       lcall bcd2hex
07B0            616   
07B0 E531       617       mov a, STATE_VAR_2
07B2 B40008     618       cjne a, #0, check_delete_b
07B5            619   
07B5 855F48     620       mov soak_temp_set+0, x+0
07B8 856049     621       mov soak_temp_set+1, x+1
07BB 8021       622       sjmp delete_done
07BD            623   
07BD            624   check_delete_b:
07BD B40108     625       cjne a, #1, check_delete_c
07C0            626   
07C0 855F4A     627       mov soak_time_set+0, x+0
07C3 85604B     628       mov soak_time_set+1, x+1
07C6 8016       629       sjmp delete_done
07C8            630   
07C8            631   check_delete_c:
07C8 B40208     632       cjne a, #2, check_delete_d
07CB            633   
07CB 855F4C     634       mov reflow_temp_set+0, x+0
07CE 85604D     635       mov reflow_temp_set+1, x+1
07D1 800B       636       sjmp delete_done
07D3            637   
07D3            638   check_delete_d:
07D3 B40308     639       cjne a, #3, delete_done
07D6            640   
07D6 855F4E     641       mov reflow_time_set+0, x+0
07D9 85604F     642       mov reflow_time_set+1, x+1
07DC 8000       643       sjmp delete_done
07DE            644   
07DE            645   delete_done:
07DE            646   
07DE C3         647            clr c
07DF 22         648            ret
07E0            649   
07E0            650   keypad_L0:
07E0            651   
07E0            652            ; Make all the rows zero.  If any column is zero then a key is pressed.
07E0 C292       653            clr ROW1
07E2 C294       654            clr ROW2
07E4 C296       655            clr ROW3
07E6 C2A0       656            clr ROW4
07E8            657   
07E8 A2A2       658            mov c, COL1
07EA 82A4       659            anl c, COL2
07EC 82A6       660            anl c, COL3
07EE 82B0       661            anl c, COL4
07F0            662   
07F0 5002       663            jnc Keypad_Debounce
07F2 C3         664            clr c
07F3 22         665            ret
07F4            666   
07F4            667   
07F4            668   Keypad_Debounce:
07F4            669            ; A key maybe pressed.  Wait and check again to discard bounces.
07F4 120784     670            lcall Wait25ms ; debounce
07F7            671   
07F7 A2A2       672            mov c, COL1
07F9 82A4       673            anl c, COL2
07FB 82A6       674            anl c, COL3
07FD 82B0       675            anl c, COL4
07FF            676   
07FF 5002       677            jnc Keypad_Key_Code
0801 C3         678            clr c
0802 22         679            ret
0803            680            
0803            681   
0803            682   Keypad_Key_Code:         
0803            683            ; A key is pressed.  Find out which one by checking each possible column and row combination.
0803            684   
0803 D292       685            setb ROW1
0805 D294       686            setb ROW2
0807 D296       687            setb ROW3
0809 D2A0       688            setb ROW4
080B            689   
080B            690            ; This check section is for an un-modified keypad
080B            691   
080B            692   keypad_default:  
080B            693   
080B            694            ; Check row 1   
080B C292       695            clr ROW1
080D 20A207     696            jb COL1, CHECK_COL_29
0810 7F01       696            mov R7, #01H
0812 30A2FD     696            jnb COL1, $ ; wait for key release
0815 D3         696            setb c
0816 22         696            ret
0817            696   CHECK_COL_29:
0817            696   
0817 20A407     697            jb COL2, CHECK_COL_30
081A 7F02       697            mov R7, #02H
081C 30A4FD     697            jnb COL2, $ ; wait for key release
081F D3         697            setb c
0820 22         697            ret
0821            697   CHECK_COL_30:
0821 20A607     698            jb COL3, CHECK_COL_31
0824 7F03       698            mov R7, #03H
0826 30A6FD     698            jnb COL3, $ ; wait for key release
0829 D3         698            setb c
082A 22         698            ret
082B            698   CHECK_COL_31:
082B 20B007     699            jb COL4, CHECK_COL_32
082E 7F0A       699            mov R7, #0AH
0830 30B0FD     699            jnb COL4, $ ; wait for key release
0833 D3         699            setb c
0834 22         699            ret
0835            699   CHECK_COL_32:
0835            700   
0835 D292       701            setb ROW1
0837            702   
0837            703            ; Check row 2   
0837            704   
0837 C294       705            clr ROW2
0839 20A207     706            jb COL1, CHECK_COL_33
083C 7F04       706            mov R7, #04H
083E 30A2FD     706            jnb COL1, $ ; wait for key release
0841 D3         706            setb c
0842 22         706            ret
0843            706   CHECK_COL_33:
0843 20A407     707            jb COL2, CHECK_COL_34
0846 7F05       707            mov R7, #05H
0848 30A4FD     707            jnb COL2, $ ; wait for key release
084B D3         707            setb c
084C 22         707            ret
084D            707   CHECK_COL_34:
084D 20A607     708            jb COL3, CHECK_COL_35
0850 7F06       708            mov R7, #06H
0852 30A6FD     708            jnb COL3, $ ; wait for key release
0855 D3         708            setb c
0856 22         708            ret
0857            708   CHECK_COL_35:
0857 20B007     709            jb COL4, CHECK_COL_36
085A 7F0B       709            mov R7, #0BH
085C 30B0FD     709            jnb COL4, $ ; wait for key release
085F D3         709            setb c
0860 22         709            ret
0861            709   CHECK_COL_36:
0861            710   
0861 D294       711            setb ROW2
0863            712   
0863            713            ; Check row 3   
0863            714   
0863 C296       715            clr ROW3
0865 20A207     716            jb COL1, CHECK_COL_37
0868 7F07       716            mov R7, #07H
086A 30A2FD     716            jnb COL1, $ ; wait for key release
086D D3         716            setb c
086E 22         716            ret
086F            716   CHECK_COL_37:
086F 20A407     717            jb COL2, CHECK_COL_38
0872 7F08       717            mov R7, #08H
0874 30A4FD     717            jnb COL2, $ ; wait for key release
0877 D3         717            setb c
0878 22         717            ret
0879            717   CHECK_COL_38:
0879 20A607     718            jb COL3, CHECK_COL_39
087C 7F09       718            mov R7, #09H
087E 30A6FD     718            jnb COL3, $ ; wait for key release
0881 D3         718            setb c
0882 22         718            ret
0883            718   CHECK_COL_39:
0883 20B007     719            jb COL4, CHECK_COL_40
0886 7F0C       719            mov R7, #0CH
0888 30B0FD     719            jnb COL4, $ ; wait for key release
088B D3         719            setb c
088C 22         719            ret
088D            719   CHECK_COL_40:
088D            720   
088D D296       721            setb ROW3
088F            722   
088F            723            ; Check row 4   
088F            724   
088F C2A0       725            clr ROW4
0891 20A207     726            jb COL1, CHECK_COL_41
0894 7F0E       726            mov R7, #0EH
0896 30A2FD     726            jnb COL1, $ ; wait for key release
0899 D3         726            setb c
089A 22         726            ret
089B            726   CHECK_COL_41:
089B 20A407     727            jb COL2, CHECK_COL_42
089E 7F00       727            mov R7, #00H
08A0 30A4FD     727            jnb COL2, $ ; wait for key release
08A3 D3         727            setb c
08A4 22         727            ret
08A5            727   CHECK_COL_42:
08A5 20A607     728            jb COL3, CHECK_COL_43
08A8 7F0F       728            mov R7, #0FH
08AA 30A6FD     728            jnb COL3, $ ; wait for key release
08AD D3         728            setb c
08AE 22         728            ret
08AF            728   CHECK_COL_43:
08AF 20B007     729            jb COL4, CHECK_COL_44
08B2 7F0D       729            mov R7, #0DH
08B4 30B0FD     729            jnb COL4, $ ; wait for key release
08B7 D3         729            setb c
08B8 22         729            ret
08B9            729   CHECK_COL_44:
08B9            730   
08B9 D2A0       731            setb ROW4
08BB            732   
08BB C3         733            clr c
08BC            734   
08BC 22         735            ret
08BD            736   
08BD            737            
08BD            738   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
08BD            739   T_7seg:
08BD C0F9A4B0   740       DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
     99
08C2 9282F880   741       DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
     90
08C7 8883C6A1   742       DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F
     868E
08CD            743   
08CD            744   
08CD            745   ; Displays a BCD number in HEX1-HEX0
08CD            746   Display_BCD_7_Seg:
08CD C0E0       747       push acc
08CF C0D0       748       push psw
08D1            749   
08D1 85355F     750            mov x+0, TEMP+0
08D4 853660     751            mov x+1, TEMP+1
08D7 756100     752       mov x+2, #0
08DA 756200     753       mov x+3, #0
08DD 120234     754            lcall hex2bcd
08E0            755   
08E0 9008BD     756            mov dptr, #T_7seg
08E3            757   
08E3 E569       758       mov a, bcd+2
08E5 C4         759       swap a
08E6 540F       760       anl a, #0FH
08E8 93         761       movc a, @a+dptr
08E9 F58F       762       mov HEX5, a
08EB            763   
08EB E569       764       mov a, bcd+2
08ED 540F       765       anl a, #0FH
08EF 93         766       movc a, @a+dptr
08F0 F58E       767       mov HEX4, a
08F2            768   
08F2 E568       769       mov a, bcd+1
08F4 C4         770       swap a
08F5 540F       771       anl a, #0FH
08F7 93         772       movc a, @a+dptr
08F8 F594       773       mov HEX3, a
08FA            774   
08FA E568       775       mov a, bcd+1
08FC 540F       776       anl a, #0FH
08FE 93         777       movc a, @a+dptr
08FF F593       778       mov HEX2, a
0901            779   
0901 E567       780            mov a, bcd
0903 C4         781            swap a
0904 540F       782            anl a, #0FH
0906 93         783            movc a, @a+dptr
0907 F592       784            mov HEX1, a
0909            785   
0909 E567       786            mov a, bcd
090B 540F       787            anl a, #0FH
090D 93         788            movc a, @a+dptr
090E F591       789            mov HEX0, a
0910            790   
0910 D0D0       791       pop psw
0912 D0E0       792       pop acc
0914            793   
0914 22         794            ret
0915            795   
0915            796   
0915            797   Check_Select_Button_Press:
0915 20B40B     798       jb SELECT_BUTTON, Not_Pressed
0918 12069A     799       lcall Wait50ms
091B 20B405     800       jb SELECT_BUTTON, Not_Pressed
091E            801   
091E D203       802       setb SELECT_BUTTON_FLAG
0920            803   
0920 30B4FD     804       jnb SELECT_BUTTON, $
0923            805   
0923            806       Not_Pressed:
0923 22         807           ret
0924            808   
0924            809   
0924            810   Check_Param_Button_Press:
0924 20B30B     811       jb PARAM_BUTTON, Not_Pressed_2
0927 12069A     812       lcall Wait50ms
092A 20B305     813       jb PARAM_BUTTON, Not_Pressed_2
092D            814   
092D D204       815       setb PARAM_BUTTON_FLAG
092F            816   
092F 30B3FD     817       jnb PARAM_BUTTON, $
0932            818   
0932            819       Not_Pressed_2:
0932 22         820           ret
0933            821   
0933            822       ;---------------READ KEYPAD-------------------;
0933            823   
0933            824       ;A Macro essentially works like CHECK_COL(COL#, Literal value coloumn represents)
0933            825       ;If the column is pressed, R7 will contain the column number (1-4)
0933            826       
0933            827   
0933            828   ;**************************PWM**************************;
0933            829   pwm_for_flatstates:
0933            830   ; ---- LOW_LIM = max(0, T_TGT - T_BAND)
0933 E544       831           MOV     A, TARGET          
0935 C3         832           CLR     C                 ;clear carry
0936 9402       833           SUBB    A, #BAND         ; A = A - BAND
0938 5002       834           JNC     flat_low_ok       
093A 7400       835           MOV     A, #00h           
093C            836   flat_low_ok:
093C F555       837           MOV     LOW_LIMIT, A        ; Store low limit in RAM
093E            838   
093E            839           ;compute high limit
093E E544       840           MOV     A, TARGET          
0940 2402       841           ADD     A, #BAND         
0942 5002       842           JNC     flat_high_ok      
0944 74FF       843           MOV     A, #0FFh          
0946            844   flat_high_ok:
0946 F557       845           MOV     HIGH_LIMIT, A       
0948            846   
0948            847           ;turn oven on if curren temp is less than low limit
0948 E535       848           MOV     A, TEMP          ;make sure this variables is right!!!!!!!
094A C3         849           CLR     C               
094B 9555       850           SUBB    A, LOW_LIMIT       
094D            851                                    
094D 400A       852           JC      flat_on       ;temp is less than low limit so turn power on since there is carry
094F            853   
094F            854           ;if current temp is greater than high lim turn off
094F E535       855           MOV     A, TEMP
0951 C3         856           CLR     C                 
0952 9557       857           SUBB    A, HIGH_LIMIT       
0954            858                                    
0954 6002       859           JZ      flat_done         ; If equal to HIGH_LIMit do nothing
0956 5004       860           JNC     flat_off      ; If no borrow and not zero T_CUR > HIGH_LIM so turn off
0958            861   
0958            862   flat_done:
0958 22         863           RET                       ; Inside band do nothing, holds prev values
0959            864   flat_on:
0959 D280       865           SETB p0.0      ;turn power on
095B 22         866           RET
095C            867   
095C            868   flat_off:
095C C280       869           CLR p0.0      ;power off
095E 22         870           RET
095F            871   
095F            872   
095F            873   
095F            874   RampBurstPWM:
095F            875   
095F            876           ;increment phase until it equals window then pahse =0
095F E55C       877           MOV     A, PHASE          
0961 04         878           INC     A                 ; A <- A + 1
0962 B40602     879           CJNE    A, #WINDOW, phase_ok  ; if A != WINDOW, keep it
0965 7400       880           MOV     A, #00h           ; else wrap to 0
0967            881   phase_ok:
0967 F55C       882           MOV     PHASE, A          ; store updated phase 
0969            883   
0969            884           ; calculate threasheld = target - lead
0969 E544       885           MOV     A, TARGET         ; A <- TARGET
096B C3         886           CLR     C                 
096C 955D       887           SUBB    A, LEAD           
096E 5002       888           JNC     thresh_ok        
0970 7400       889           MOV     A, #00h           
0972            890   thresh_ok:
0972 F559       891           MOV     THRESHOLD, A         
0974            892   
0974            893           ;if temp is less than threshold, full power
0974 E535       894           MOV     A, TEMP           
0976 C3         895           CLR     C
0977 9559       896           SUBB    A, THRESHOLD         
0979 4010       897           JC      force_on         
097B            898   
097B            899           ; if temp is greater than target then off
097B E535       900           MOV     A, TEMP           
097D C3         901           CLR     C
097E 9544       902           SUBB    A, TARGET         
0980 500C       903           JNC     force_off         
0982            904   
0982            905           ;else burst pwm 
0982            906           ; CMD_ON = 1 if PHASE < ON_SECS else 0
0982 E55C       907           MOV     A, PHASE          ; A <- PHASE (0..WINDOW-1)
0984 C3         908           CLR     C
0985 955B       909           SUBB    A, ON_SECS        ; A <- PHASE - ON_SECS
0987            910                                    ; borrow => PHASE < ON_SECS
0987 4008       911           JC      burst_on          ; if PHASE < ON_SECS => ON
0989 8009       912           SJMP    burst_off         ; else OFF
098B            913   
098B            914   force_on:
098B D280       915           SETB p0.0      ;less than threshold
098D 22         916           RET
098E            917   
098E            918   force_off:
098E C280       919           CLR p0.0      
0990 22         920           RET
0991            921   
0991            922   burst_on:
0991 D280       923           SETB p0.0      ; ON for ON_SECS seconds each window
0993 22         924           RET
0994            925   
0994            926   burst_off:
0994 C280       927           CLR p0.0      ; OFF for remaining seconds
0996 22         928           RET
0997            929   
0997            930   
0997            931   
0997            932   
0997            933   ;==============SPEAKER FUNCTIONS==============;
0997            934   
0997            935   BeepSpeaker:
0997 D28C       936       setb TR0
0999 7B07       937       mov R3, #7
099B            938   WaitLoop:
099B 12069A     939       lcall Wait50ms
099E DBFB       940       djnz R3, WaitLoop 
09A0            941   UnbeepSpeaker:
09A0 C28C       942       clr TR0
09A2 22         943       ret
09A3            944   
09A3            945   ;=============================================;
09A3            946   
09A3            947   FSM2_Temp_Time_display:
09A3            948       ;print time
09A3 C0E0       949            push acc
09A5 7401       949            mov a, #1
09A7 14         949            dec a
09A8 120217     949            lcall ?Set_Cursor_2 ; Select column and row
09AB D0E0       949            pop acc
09AD C083       950            push dph
09AF C082       950            push dpl
09B1 C0E0       950            push acc
09B3 900171     950            mov dptr, #TimeLabel
09B6 12020C     950            lcall ?Send_Constant_String
09B9 D0E0       950            pop acc
09BB D082       950            pop dpl
09BD D083       950            pop dph
09BF            951   
09BF 853A5F     952       mov x+0, TIME+0
09C2 853B60     953       mov x+1, TIME+1
09C5 756100     954       mov x+2, #0
09C8 756200     955       mov x+3, #0
09CB 120234     956       lcall hex2bcd
09CE            957   
09CE C0E0       958            push acc
09D0 7406       958            mov a, #6
09D2 14         958            dec a
09D3 120217     958            lcall ?Set_Cursor_2 ; Select column and row
09D6 D0E0       958            pop acc
09D8 C000       959            push ar0
09DA A868       959            mov r0, bcd+1
09DC 12021E     959            lcall ?Display_BCD
09DF D000       959            pop ar0
09E1 C000       960            push ar0
09E3 A867       960            mov r0, bcd+0
09E5 12021E     960            lcall ?Display_BCD
09E8 D000       960            pop ar0
09EA            961       ;print temp
09EA C0E0       962            push acc
09EC 740A       962            mov a, #10
09EE 14         962            dec a
09EF 120217     962            lcall ?Set_Cursor_2 ; Select column and row
09F2 D0E0       962            pop acc
09F4 C083       963            push dph
09F6 C082       963            push dpl
09F8 C0E0       963            push acc
09FA 900177     963            mov dptr, #TempLabel
09FD 12020C     963            lcall ?Send_Constant_String
0A00 D0E0       963            pop acc
0A02 D082       963            pop dpl
0A04 D083       963            pop dph
0A06            964   
0A06 85355F     965       mov x+0, TEMP+0
0A09 853660     966       mov x+1, TEMP+1
0A0C 756100     967       mov x+2, #0
0A0F 756200     968       mov x+3, #0
0A12 120234     969       lcall hex2bcd
0A15            970   
0A15 C0E0       971            push acc
0A17 740D       971            mov a, #16-3
0A19 14         971            dec a
0A1A 120217     971            lcall ?Set_Cursor_2 ; Select column and row
0A1D D0E0       971            pop acc      
0A1F C000       972            push ar0
0A21 A868       972            mov r0, bcd+1
0A23 12021E     972            lcall ?Display_BCD
0A26 D000       972            pop ar0
0A28 C000       973            push ar0
0A2A A867       973            mov r0, bcd+0
0A2C 12021E     973            lcall ?Display_BCD
0A2F D000       973            pop ar0
0A31 22         974       ret
0A32            975   
0A32            976   ;--- MAIN PROGRAM START ---
0A32            977   
0A32            978   ; **************************************** Initializations ***********************************************
0A32            979   
0A32            980   MAIN:
0A32 75817F     981       mov SP, #0x7F         ; Initialize Stack Pointer (Good practice)
0A35 120687     982       lcall INITIALIZE      ; intialize pins and adc, for now
0A38            983   
0A38 12058A     984       lcall Timer0_Init
0A3B 1205A6     985       lcall Timer2_Init
0A3E D2AF       986       setB EA ; Enable global interrupts
0A40 1201D9     987       lcall ELCD_4BIT ; Intialize LCD
0A43 120526     988       lcall InitSerialPort
0A46            989       
0A46 C202       990       clr seconds_flag
0A48 C200       991       clr START_FLAG
0A4A C205       992       clr KEYPAD_FLAG
0A4C C280       993       clr p0.0 ; Make sure oven is off to start
0A4E C28C       994       clr TR0 ; Start speaker off
0A50 E4         995       clr a
0A51 C290       996       clr RED_LED
0A53 C2B1       997       clr GREEN_LED
0A55            998   
0A55            999   
0A55 753000    1000       mov STATE_VAR_1, #0x0000
0A58 753100    1001       mov STATE_VAR_2, #0x0000
0A5B 753A00    1002       mov TIME, #0
0A5E 753500    1003       mov TEMP, #0000
0A61 753C00    1004       mov POWER, #0
0A64 753E3C    1005       mov DEGREES60, #60
0A67 754096    1006       mov DEGREES150, #150
0A6A 7542DC    1007       mov DEGREES220, #220
0A6D 754400    1008       mov TARGET,       #0
0A70           1009   
0A70 756700    1010       mov bcd, #0x0000
0A73 755F00    1011       mov x+0, #0x0000
0A76 756000    1012       mov x+1, #0x0000
0A79 756100    1013       mov x+2, #0x0000
0A7C 756200    1014       mov x+3, #0x0000
0A7F           1015   
0A7F 754896    1016       mov soak_temp_set+0, #150
0A82 F549      1017       mov soak_temp_set+1, a
0A84           1018   
0A84 754A3C    1019       mov soak_time_set+0, #60
0A87 F54B      1020       mov soak_time_set+1, a
0A89           1021   
0A89 754CDC    1022       mov reflow_temp_set+0, #220
0A8C F54D      1023       mov reflow_temp_set+1, a
0A8E           1024   
0A8E 754E1E    1025       mov reflow_time_set+0, #30
0A91 F54F      1026       mov reflow_time_set+1, a
0A93           1027   
0A93           1028   
0A93           1029   MAIN_LOOP:
0A93           1030   
0A93           1031   ; **************************** Preset Settings **************************************
0A93           1032   
0A93           1033   ;StatePInit:
0A93           1034   ;    Set_Cursor(1,1)
0A93           1035   ;    Send_Constant_String (#preset_message)
0A93           1036   
0A93           1037   
0A93           1038   
0A93           1039   PARAM_FSM:
0A93           1040   
0A93           1041   ; **************************** FSM for selecting parameters *************************
0A93           1042   
0A93           1043   ; 4 main states ->  A: select soak temp
0A93           1044   ;                   B: select soak time
0A93           1045   ;                   C: select reflow temp
0A93           1046   ;                   D: select reflow time
0A93           1047   ; move to other FSM when start button turns on start flag
0A93           1048   
0A93           1049   StateAInit:
0A93 C0E0      1050            push acc
0A95 7401      1050            mov a, #1
0A97 14        1050            dec a
0A98 120219    1050            lcall ?Set_Cursor_1 ; Select column and row
0A9B D0E0      1050            pop acc
0A9D C083      1051            push dph
0A9F C082      1051            push dpl
0AA1 C0E0      1051            push acc
0AA3 900050    1051            mov dptr, #param_message
0AA6 12020C    1051            lcall ?Send_Constant_String
0AA9 D0E0      1051            pop acc
0AAB D082      1051            pop dpl
0AAD D083      1051            pop dph
0AAF C0E0      1052            push acc
0AB1 7401      1052            mov a, #1
0AB3 14        1052            dec a
0AB4 120217    1052            lcall ?Set_Cursor_2 ; Select column and row
0AB7 D0E0      1052            pop acc
0AB9 C083      1053            push dph
0ABB C082      1053            push dpl
0ABD C0E0      1053            push acc
0ABF 900061    1053            mov dptr, #soak_temp_message
0AC2 12020C    1053            lcall ?Send_Constant_String
0AC5 D0E0      1053            pop acc
0AC7 D082      1053            pop dpl
0AC9 D083      1053            pop dph
0ACB           1053   
0ACB           1054   
0ACB C205      1055       clr KEYPAD_FLAG
0ACD 756F00    1056       mov keypad_digit_count, #0
0AD0           1057   
0AD0           1058   StateA:
0AD0 30B23E    1059       jnb RESET_BUTTON, StateA_ResetToMain
0AD3 E531      1060       mov a, STATE_VAR_2
0AD5 B4003C    1061       cjne a, #0, StateA_B
0AD8           1062   
0AD8 120915    1063       lcall Check_Select_Button_Press
0ADB 200339    1064       jb SELECT_BUTTON_FLAG, StateAtoDone
0ADE           1065   
0ADE 85485F    1066       mov x+0, soak_temp_set+0
0AE1 854960    1067       mov x+1, soak_temp_set+1
0AE4 756100    1068       mov x+2, #0
0AE7 756200    1069       mov x+3, #0
0AEA 120234    1070       lcall hex2bcd
0AED           1071   
0AED C0E0      1072            push acc
0AEF 740C      1072            mov a, #12
0AF1 14        1072            dec a
0AF2 120217    1072            lcall ?Set_Cursor_2 ; Select column and row
0AF5 D0E0      1072            pop acc
0AF7 C000      1073            push ar0
0AF9 A868      1073            mov r0, bcd+1
0AFB 12021E    1073            lcall ?Display_BCD
0AFE D000      1073            pop ar0
0B00 C000      1074            push ar0
0B02 A867      1074            mov r0, bcd+0
0B04 12021E    1074            lcall ?Display_BCD
0B07 D000      1074            pop ar0
0B09           1075   
0B09 120924    1076       lcall Check_Param_Button_Press
0B0C 20045B    1077       jb PARAM_BUTTON_FLAG, Inc_Soak_Temp
0B0F 8009      1078       sjmp StateA_Keypad
0B11           1079   
0B11           1080   StateA_ResetToMain:
0B11 020A32    1081   ljmp MAIN   
0B14           1082   
0B14           1083   StateA_B:
0B14 020B9D    1084   ljmp StateBInit
0B17           1085   
0B17           1086   StateAtoDone:
0B17 020B8E    1087   ljmp StateADone
0B1A           1088   
0B1A           1089   StateA_Keypad:
0B1A 12079E    1090       lcall Keypad
0B1D 50B1      1091       jnc StateA
0B1F           1092   
0B1F 20050C    1093       jb KEYPAD_FLAG, StateA_Keypad_Continue
0B22 D205      1094       setb KEYPAD_FLAG
0B24           1095   
0B24 7400      1096       mov a, #0
0B26 F567      1097       mov bcd+0, a
0B28 F568      1098       mov bcd+1, a
0B2A F569      1099       mov bcd+2, a
0B2C F56A      1100       mov bcd+3, a
0B2E           1101   
0B2E           1102   StateA_Keypad_Continue:
0B2E 12071D    1103       lcall Shift_Digits_Left
0B31 509D      1104       jnc StateA
0B33           1105   
0B33 120281    1106       lcall bcd2hex
0B36           1107   
0B36 855F48    1108       mov soak_temp_set+0, x+0
0B39 856049    1109       mov soak_temp_set+1, x+1
0B3C           1110   
0B3C 85485F    1111       mov x+0, soak_temp_set+0
0B3F 854960    1112       mov x+1, soak_temp_set+1
0B42 756100    1113       mov x+2, #0
0B45 756200    1114       mov x+3, #0
0B48 120234    1115       lcall hex2bcd
0B4B           1116   
0B4B C0E0      1117            push acc
0B4D 740C      1117            mov a, #12
0B4F 14        1117            dec a
0B50 120217    1117            lcall ?Set_Cursor_2 ; Select column and row
0B53 D0E0      1117            pop acc
0B55 C000      1118            push ar0
0B57 A868      1118            mov r0, bcd+1
0B59 12021E    1118            lcall ?Display_BCD
0B5C D000      1118            pop ar0
0B5E C000      1119            push ar0
0B60 A867      1119            mov r0, bcd+0
0B62 12021E    1119            lcall ?Display_BCD
0B65 D000      1119            pop ar0
0B67           1120   
0B67 020AD0    1121       ljmp StateA
0B6A           1122   
0B6A           1123   
0B6A           1124       Inc_Soak_Temp:
0B6A C204      1125           clr PARAM_BUTTON_FLAG
0B6C           1126   
0B6C E548      1127           mov a, soak_temp_set
0B6E           1128   
0B6E 20E80B    1129           jb UPDOWN, Dec_Soak_Temp
0B71 20E904    1130           jb TENS, Inc_Soak_Temp_Tens
0B74           1131   
0B74 2401      1132           add a, #1
0B76 8011      1133           sjmp Soak_Temp_Tens_Done
0B78           1134   
0B78           1135       Inc_Soak_Temp_Tens:
0B78 240A      1136           add a, #10
0B7A 800D      1137           sjmp Soak_Temp_Tens_Done
0B7C           1138   
0B7C           1139       Dec_Soak_Temp:
0B7C 20E905    1140           jb TENS, Dec_Soak_Temp_Tens
0B7F           1141   
0B7F C3        1142           clr c
0B80 9401      1143           subb a, #1
0B82 8005      1144           sjmp Soak_Temp_Tens_Done
0B84           1145   
0B84           1146       Dec_Soak_Temp_Tens:
0B84 C3        1147           clr c  
0B85 940A      1148           subb a, #10
0B87 8000      1149           sjmp Soak_Temp_Tens_Done
0B89           1150   
0B89           1151       Soak_Temp_Tens_Done:
0B89 F548      1152           mov soak_temp_set, a
0B8B 020AD0    1153           ljmp StateA
0B8E           1154   
0B8E           1155   StateADone:
0B8E 120997    1156       lcall BeepSpeaker
0B91 0531      1157       inc STATE_VAR_2
0B93 C203      1158       clr SELECT_BUTTON_FLAG
0B95 C205      1159       clr KEYPAD_FLAG
0B97 756F00    1160       mov keypad_digit_count, #0
0B9A 020AD0    1161       ljmp StateA
0B9D           1162   
0B9D           1163   
0B9D           1164   StateBInit:
0B9D C0E0      1165            push acc
0B9F 7401      1165            mov a, #1
0BA1 14        1165            dec a
0BA2 120217    1165            lcall ?Set_Cursor_2 ; Select column and row
0BA5 D0E0      1165            pop acc
0BA7 C083      1166            push dph
0BA9 C082      1166            push dpl
0BAB C0E0      1166            push acc
0BAD 900072    1166            mov dptr, #soak_time_message
0BB0 12020C    1166            lcall ?Send_Constant_String
0BB3 D0E0      1166            pop acc
0BB5 D082      1166            pop dpl
0BB7 D083      1166            pop dph
0BB9           1167   
0BB9           1168   StateB:
0BB9 30B236    1169       jnb RESET_BUTTON, StateB_ResetToMain
0BBC E531      1170       mov a, STATE_VAR_2
0BBE B40134    1171       cjne a, #1, StateB_C
0BC1           1172   
0BC1 120915    1173       lcall Check_Select_Button_Press
0BC4 200331    1174       jb SELECT_BUTTON_FLAG, StateBtoDone
0BC7           1175   
0BC7 854A5F    1176       mov x+0, soak_time_set+0
0BCA 756000    1177       mov x+1, #0
0BCD 756100    1178       mov x+2, #0
0BD0 756200    1179       mov x+3, #0
0BD3 120234    1180       lcall hex2bcd
0BD6           1181   
0BD6 C0E0      1182            push acc
0BD8 740C      1182            mov a, #12
0BDA 14        1182            dec a
0BDB 120217    1182            lcall ?Set_Cursor_2 ; Select column and row
0BDE D0E0      1182            pop acc
0BE0 C000      1183            push ar0
0BE2 A867      1183            mov r0, bcd+0
0BE4 12021E    1183            lcall ?Display_BCD
0BE7 D000      1183            pop ar0
0BE9           1184   
0BE9 120924    1185       lcall Check_Param_Button_Press
0BEC 200450    1186       jb PARAM_BUTTON_FLAG, Inc_Soak_Time
0BEF 020BFB    1187       ljmp StateB_Keypad
0BF2           1188   
0BF2           1189   StateB_ResetToMain:
0BF2 020A32    1190   ljmp MAIN
0BF5           1191   
0BF5           1192   StateB_C:
0BF5 020C72    1193   ljmp StateCInit
0BF8           1194   
0BF8           1195   StateBtoDone:
0BF8 020C63    1196   ljmp StateBDone
0BFB           1197   
0BFB           1198   StateB_Keypad:
0BFB 12079E    1199       lcall Keypad
0BFE 50B9      1200       jnc StateB
0C00           1201   
0C00 20050C    1202       jb KEYPAD_FLAG, StateB_Keypad_Continue
0C03 D205      1203       setb KEYPAD_FLAG
0C05           1204   
0C05 7400      1205       mov a, #0
0C07 F567      1206       mov bcd+0, a
0C09 F568      1207       mov bcd+1, a
0C0B F569      1208       mov bcd+2, a
0C0D F56A      1209       mov bcd+3, a
0C0F           1210   
0C0F           1211   StateB_Keypad_Continue:
0C0F 12071D    1212       lcall Shift_Digits_Left
0C12 50A5      1213       jnc StateB
0C14           1214   
0C14 120281    1215       lcall bcd2hex
0C17           1216   
0C17 855F4A    1217       mov soak_time_set+0, x+0
0C1A           1218   
0C1A 854A5F    1219       mov x+0, soak_time_set+0
0C1D 756000    1220       mov x+1, #0
0C20 756100    1221       mov x+2, #0
0C23 756200    1222       mov x+3, #0
0C26 120234    1223       lcall hex2bcd
0C29           1224   
0C29 C0E0      1225            push acc
0C2B 740C      1225            mov a, #12
0C2D 14        1225            dec a
0C2E 120217    1225            lcall ?Set_Cursor_2 ; Select column and row
0C31 D0E0      1225            pop acc
0C33 C000      1226            push ar0
0C35 A867      1226            mov r0, bcd+0
0C37 12021E    1226            lcall ?Display_BCD
0C3A D000      1226            pop ar0
0C3C           1227   
0C3C 020BB9    1228       ljmp StateB
0C3F           1229   
0C3F           1230   
0C3F           1231       Inc_Soak_Time:
0C3F C204      1232           clr PARAM_BUTTON_FLAG
0C41           1233   
0C41 E54A      1234           mov a, soak_time_set
0C43           1235   
0C43 20E80B    1236           jb UPDOWN, Dec_Soak_Time
0C46 20E904    1237           jb TENS, Inc_Soak_Time_Tens
0C49           1238   
0C49 2401      1239           add a, #1
0C4B 8011      1240           sjmp Soak_Time_Tens_Done
0C4D           1241   
0C4D           1242       Inc_Soak_Time_Tens:
0C4D 240A      1243           add a, #10
0C4F 800D      1244           sjmp Soak_Time_Tens_Done
0C51           1245   
0C51           1246       Dec_Soak_Time:
0C51 20E905    1247           jb TENS, Dec_Soak_Time_Tens
0C54 C3        1248           clr c
0C55           1249   
0C55 9401      1250           subb a, #1
0C57 8005      1251           sjmp Soak_Time_Tens_Done
0C59           1252   
0C59           1253       Dec_Soak_Time_Tens:
0C59 C3        1254           clr c
0C5A           1255   
0C5A 940A      1256           subb a, #10
0C5C 8000      1257           sjmp Soak_Time_Tens_Done
0C5E           1258   
0C5E           1259       Soak_Time_Tens_Done:
0C5E F54A      1260           mov soak_time_set, a
0C60 020BB9    1261           ljmp StateB
0C63           1262   
0C63           1263   StateBDone:
0C63 120997    1264       lcall BeepSpeaker
0C66 0531      1265       inc STATE_VAR_2
0C68 C203      1266       clr SELECT_BUTTON_FLAG
0C6A C205      1267       clr KEYPAD_FLAG
0C6C 756F00    1268       mov keypad_digit_count, #0
0C6F 020BB9    1269       ljmp StateB
0C72           1270   
0C72           1271   
0C72           1272   StateCInit:
0C72 C0E0      1273            push acc
0C74 7401      1273            mov a, #1
0C76 14        1273            dec a
0C77 120217    1273            lcall ?Set_Cursor_2 ; Select column and row
0C7A D0E0      1273            pop acc
0C7C C083      1274            push dph
0C7E C082      1274            push dpl
0C80 C0E0      1274            push acc
0C82 900083    1274            mov dptr, #reflow_temp_message
0C85 12020C    1274            lcall ?Send_Constant_String
0C88 D0E0      1274            pop acc
0C8A D082      1274            pop dpl
0C8C D083      1274            pop dph
0C8E           1275   StateC:
0C8E 30B23F    1276       jnb RESET_BUTTON, StateC_ResetToMain
0C91 E531      1277       mov a, STATE_VAR_2
0C93 B4023D    1278       cjne a, #2, StateC_D
0C96           1279   
0C96 120915    1280       lcall Check_Select_Button_Press
0C99 20033A    1281       jb SELECT_BUTTON_FLAG, StateCtoDone
0C9C           1282   
0C9C 854C5F    1283       mov x+0, reflow_temp_set+0
0C9F 854D60    1284       mov x+1, reflow_temp_set+1
0CA2 756100    1285       mov x+2, #0x0000
0CA5 756200    1286       mov x+3, #0x0000
0CA8           1287   
0CA8 120234    1288       lcall hex2bcd
0CAB           1289   
0CAB C0E0      1290            push acc
0CAD 740C      1290            mov a, #12
0CAF 14        1290            dec a
0CB0 120217    1290            lcall ?Set_Cursor_2 ; Select column and row
0CB3 D0E0      1290            pop acc
0CB5 C000      1291            push ar0
0CB7 A868      1291            mov r0, bcd+1
0CB9 12021E    1291            lcall ?Display_BCD
0CBC D000      1291            pop ar0
0CBE C000      1292            push ar0
0CC0 A867      1292            mov r0, bcd+0
0CC2 12021E    1292            lcall ?Display_BCD
0CC5 D000      1292            pop ar0
0CC7           1293   
0CC7 120924    1294       lcall Check_Param_Button_Press
0CCA 20045C    1295       jb PARAM_BUTTON_FLAG, Inc_Reflow_Temp
0CCD 020CD9    1296       ljmp StateC_Keypad
0CD0           1297   
0CD0           1298   StateC_ResetToMain:
0CD0 020A32    1299   ljmp MAIN
0CD3           1300   
0CD3           1301   StateC_D:
0CD3 020D5C    1302   ljmp StateDInit
0CD6           1303   
0CD6           1304   StateCtoDone:
0CD6 020D4D    1305   ljmp StateCDone
0CD9           1306   
0CD9           1307   StateC_Keypad:
0CD9 12079E    1308       lcall Keypad
0CDC 50B0      1309       jnc StateC
0CDE           1310   
0CDE 20050C    1311       jb KEYPAD_FLAG, StateC_Keypad_Continue
0CE1 D205      1312       setb KEYPAD_FLAG
0CE3           1313   
0CE3 7400      1314       mov a, #0
0CE5 F567      1315       mov bcd+0, a
0CE7 F568      1316       mov bcd+1, a
0CE9 F569      1317       mov bcd+2, a
0CEB F56A      1318       mov bcd+3, a
0CED           1319   
0CED           1320   StateC_Keypad_Continue:
0CED 12071D    1321       lcall Shift_Digits_Left
0CF0 509C      1322       jnc StateC
0CF2           1323   
0CF2 120281    1324       lcall bcd2hex
0CF5           1325   
0CF5 855F4C    1326       mov reflow_temp_set+0, x+0
0CF8 85604D    1327       mov reflow_temp_set+1, x+1
0CFB           1328   
0CFB 854C5F    1329       mov x+0, reflow_temp_set+0
0CFE 854D60    1330       mov x+1, reflow_temp_set+1
0D01 756100    1331       mov x+2, #0
0D04 756200    1332       mov x+3, #0
0D07 120234    1333       lcall hex2bcd
0D0A           1334   
0D0A C0E0      1335            push acc
0D0C 740C      1335            mov a, #12
0D0E 14        1335            dec a
0D0F 120217    1335            lcall ?Set_Cursor_2 ; Select column and row
0D12 D0E0      1335            pop acc
0D14 C000      1336            push ar0
0D16 A868      1336            mov r0, bcd+1
0D18 12021E    1336            lcall ?Display_BCD
0D1B D000      1336            pop ar0
0D1D C000      1337            push ar0
0D1F A867      1337            mov r0, bcd+0
0D21 12021E    1337            lcall ?Display_BCD
0D24 D000      1337            pop ar0
0D26           1338   
0D26 020C8E    1339       ljmp StateC
0D29           1340   
0D29           1341   
0D29           1342       Inc_Reflow_Temp:
0D29 C204      1343           clr PARAM_BUTTON_FLAG
0D2B           1344   
0D2B E54C      1345           mov a, reflow_temp_set
0D2D           1346   
0D2D 20E80B    1347           jb UPDOWN, Dec_Reflow_Temp
0D30 20E904    1348           jb TENS, Inc_Reflow_Temp_Tens
0D33           1349   
0D33 2401      1350           add a, #1
0D35 8011      1351           sjmp Reflow_Temp_Tens_Done
0D37           1352   
0D37           1353       Inc_Reflow_Temp_Tens:
0D37 240A      1354           add a, #10
0D39 800D      1355           sjmp Reflow_Temp_Tens_Done
0D3B           1356   
0D3B           1357       Dec_Reflow_Temp:
0D3B 20E905    1358           jb TENS, Dec_Reflow_Temp_Tens
0D3E           1359   
0D3E C3        1360           clr c
0D3F 9401      1361           subb a, #1
0D41 8005      1362           sjmp Reflow_Temp_Tens_Done
0D43           1363   
0D43           1364       Dec_Reflow_Temp_Tens:
0D43 C3        1365           clr c
0D44 940A      1366           subb a, #10
0D46 8000      1367           sjmp Reflow_Temp_Tens_Done
0D48           1368   
0D48           1369       Reflow_Temp_Tens_Done:
0D48 F54C      1370           mov reflow_temp_set, a
0D4A 020C8E    1371           ljmp StateC
0D4D           1372   
0D4D           1373   StateCDone:
0D4D 120997    1374       lcall BeepSpeaker
0D50 0531      1375       inc STATE_VAR_2
0D52 C203      1376       clr SELECT_BUTTON_FLAG
0D54 C205      1377       clr KEYPAD_FLAG
0D56 756F00    1378       mov keypad_digit_count, #0
0D59 020C8E    1379       ljmp StateC
0D5C           1380   
0D5C           1381   
0D5C           1382   StateDInit:
0D5C C0E0      1383            push acc
0D5E 7401      1383            mov a, #1
0D60 14        1383            dec a
0D61 120217    1383            lcall ?Set_Cursor_2 ; Select column and row
0D64 D0E0      1383            pop acc
0D66 C083      1384            push dph
0D68 C082      1384            push dpl
0D6A C0E0      1384            push acc
0D6C 900094    1384            mov dptr, #reflow_time_message
0D6F 12020C    1384            lcall ?Send_Constant_String
0D72 D0E0      1384            pop acc
0D74 D082      1384            pop dpl
0D76 D083      1384            pop dph
0D78           1385   
0D78           1386   StateD:
0D78 30B235    1387       jnb RESET_BUTTON, StateD_ResetToMain
0D7B E531      1388       mov a, STATE_VAR_2
0D7D B40333    1389       cjne a, #3, StateD_R
0D80           1390   
0D80 120915    1391       lcall Check_Select_Button_Press
0D83 200330    1392       jb SELECT_BUTTON_FLAG, StateDtoDone
0D86           1393   
0D86 854E5F    1394       mov x+0, reflow_time_set+0
0D89 756000    1395       mov x+1, #0
0D8C 756100    1396       mov x+2, #0
0D8F 756200    1397       mov x+3, #0
0D92 120234    1398       lcall hex2bcd
0D95           1399   
0D95 C0E0      1400            push acc
0D97 740C      1400            mov a, #12
0D99 14        1400            dec a
0D9A 120217    1400            lcall ?Set_Cursor_2 ; Select column and row
0D9D D0E0      1400            pop acc
0D9F C000      1401            push ar0
0DA1 A867      1401            mov r0, bcd+0
0DA3 12021E    1401            lcall ?Display_BCD
0DA6 D000      1401            pop ar0
0DA8           1402   
0DA8 120924    1403       lcall Check_Param_Button_Press
0DAB 20044F    1404       jb PARAM_BUTTON_FLAG, Inc_Reflow_Time
0DAE 8009      1405       sjmp StateD_Keypad
0DB0           1406   
0DB0           1407   StateD_ResetToMain:
0DB0 020A32    1408   ljmp MAIN
0DB3           1409   
0DB3           1410   StateD_R:
0DB3 020E30    1411   ljmp ReadyStateInit
0DB6           1412   
0DB6           1413   StateDtoDone:
0DB6 020E21    1414   ljmp StateDDone
0DB9           1415   
0DB9           1416   StateD_Keypad:
0DB9 12079E    1417       lcall Keypad 
0DBC 50BA      1418       jnc StateD
0DBE           1419   
0DBE 20050C    1420       jb KEYPAD_FLAG, StateD_Keypad_Continue
0DC1 D205      1421       setb KEYPAD_FLAG
0DC3           1422   
0DC3 7400      1423       mov a, #0
0DC5 F567      1424       mov bcd+0, a
0DC7 F568      1425       mov bcd+1, a
0DC9 F569      1426       mov bcd+2, a
0DCB F56A      1427       mov bcd+3, a
0DCD           1428   
0DCD           1429   StateD_Keypad_Continue:
0DCD 12071D    1430       lcall Shift_Digits_Left
0DD0 50A6      1431       jnc StateD
0DD2           1432   
0DD2 120281    1433       lcall bcd2hex
0DD5           1434   
0DD5 855F4E    1435       mov reflow_time_set+0, x+0
0DD8           1436       ;mov reflow_time_set+1, x+1
0DD8           1437   
0DD8 854E5F    1438       mov x+0, reflow_time_set+0
0DDB 756000    1439       mov x+1, #0
0DDE 756100    1440       mov x+2, #0
0DE1 756200    1441       mov x+3, #0
0DE4 120234    1442       lcall hex2bcd
0DE7           1443   
0DE7 C0E0      1444            push acc
0DE9 740C      1444            mov a, #12
0DEB 14        1444            dec a
0DEC 120217    1444            lcall ?Set_Cursor_2 ; Select column and row
0DEF D0E0      1444            pop acc
0DF1           1445       ;Display_BCD(bcd+1)
0DF1 C000      1446            push ar0
0DF3 A867      1446            mov r0, bcd+0
0DF5 12021E    1446            lcall ?Display_BCD
0DF8 D000      1446            pop ar0
0DFA           1447   
0DFA 020D78    1448       ljmp StateD
0DFD           1449   
0DFD           1450   
0DFD           1451       Inc_Reflow_Time:        
0DFD C204      1452           clr PARAM_BUTTON_FLAG
0DFF E54E      1453           mov a, reflow_time_set
0E01           1454   
0E01 20E80B    1455           jb UPDOWN, Dec_Reflow_Time
0E04 20E904    1456           jb TENS, Inc_Reflow_Time_Tens
0E07           1457   
0E07 2401      1458           add a, #1
0E09 8011      1459           sjmp Reflow_Time_Tens_Done
0E0B           1460   
0E0B           1461       Inc_Reflow_Time_Tens:
0E0B 240A      1462           add a, #10
0E0D 800D      1463           sjmp Reflow_Time_Tens_Done
0E0F           1464   
0E0F           1465       Dec_Reflow_Time:
0E0F 20E905    1466           jb TENS, Dec_Reflow_Time_Tens
0E12           1467   
0E12 C3        1468           clr c
0E13 9401      1469           subb a, #1
0E15 8005      1470           sjmp Reflow_Time_Tens_Done
0E17           1471   
0E17           1472       Dec_Reflow_Time_Tens:
0E17 C3        1473           clr c
0E18 940A      1474           subb a, #10
0E1A 8000      1475           sjmp Reflow_Time_Tens_Done
0E1C           1476   
0E1C           1477       Reflow_Time_Tens_Done:
0E1C F54E      1478           mov reflow_time_set, a
0E1E 020D78    1479           ljmp StateD
0E21           1480   
0E21           1481   StateDDone:
0E21 120997    1482       lcall BeepSpeaker
0E24 0531      1483       inc STATE_VAR_2
0E26 C203      1484       clr SELECT_BUTTON_FLAG
0E28 C205      1485       clr KEYPAD_FLAG
0E2A 756F00    1486       mov keypad_digit_count, #0
0E2D 020D78    1487       ljmp StateD
0E30           1488   
0E30           1489   
0E30           1490   ReadyStateInit:
0E30 C0E0      1491            push acc
0E32 7401      1491            mov a, #1
0E34 14        1491            dec a
0E35 120219    1491            lcall ?Set_Cursor_1 ; Select column and row
0E38 D0E0      1491            pop acc
0E3A C083      1492            push dph
0E3C C082      1492            push dpl
0E3E C0E0      1492            push acc
0E40 9000A5    1492            mov dptr, #ready_message
0E43 12020C    1492            lcall ?Send_Constant_String
0E46 D0E0      1492            pop acc
0E48 D082      1492            pop dpl
0E4A D083      1492            pop dph
0E4C C0E0      1493            push acc
0E4E 7401      1493            mov a, #1
0E50 14        1493            dec a
0E51 120217    1493            lcall ?Set_Cursor_2 ; Select column and row
0E54 D0E0      1493            pop acc
0E56 C083      1494            push dph
0E58 C082      1494            push dpl
0E5A C0E0      1494            push acc
0E5C 90002E    1494            mov dptr, #blank_row
0E5F 12020C    1494            lcall ?Send_Constant_String
0E62 D0E0      1494            pop acc
0E64 D082      1494            pop dpl
0E66 D083      1494            pop dph
0E68           1495   
0E68           1496   ReadyState:
0E68           1497       ;jnb seconds_flag, skipSerial_0 *** not too sure what this does
0E68           1498   
0E68           1499   skipSerial_0:
0E68 20B5FD    1500       jb START_BUTTON, ReadyState
0E6B 12069A    1501       lcall wait50ms
0E6E 20B5F7    1502       jb START_BUTTON, ReadyState
0E71           1503   
0E71 C0E0      1504            push acc
0E73 7401      1504            mov a, #1
0E75 14        1504            dec a
0E76 120219    1504            lcall ?Set_Cursor_1 ; Select column and row
0E79 D0E0      1504            pop acc
0E7B C083      1505            push dph
0E7D C082      1505            push dpl
0E7F C0E0      1505            push acc
0E81 9000B6    1505            mov dptr, #state0_message
0E84 12020C    1505            lcall ?Send_Constant_String
0E87 D0E0      1505            pop acc
0E89 D082      1505            pop dpl
0E8B D083      1505            pop dph
0E8D           1506   
0E8D D200      1507       setb START_FLAG
0E8F           1508       
0E8F 8000      1509       sjmp State0
0E91           1510   
0E91           1511   ;==================Reflow Profile FSM==================;
0E91           1512   ;Checklist:
0E91           1513   ; 1. Implement TEMP and TIME variables - DONE
0E91           1514   ; 2. Implement FSM outputs - DONE
0E91           1515   ; 3. Implement reset logic - DONE
0E91           1516   ; 4. Implement abort condition - DONE
0E91           1517   ; 5. Implement LCD Feedback for Each State - Tentatively Done (Still not tested)
0E91           1518   ; 6. Speaker beeps for state transitions - DONE
0E91           1519   ;*Abort condition needs to be in state 1* - FIXED
0E91           1520   ; 7. Rewrite State Transitions with SUBB - DONE
0E91           1521   State0:
0E91 30B70F    1522       jnb STOP_BUTTON, State0_StopReflow
0E94 C280      1523       CLR p0.0 ;oven off
0E96 E530      1524       mov a, STATE_VAR_1
0E98 753A00    1525       mov TIME, #0
0E9B B4001E    1526       cjne a, #0, State1
0E9E 200005    1527       jb START_FLAG, State0Done
0EA1 80EE      1528       sjmp State0
0EA3           1529   
0EA3           1530   State0_StopReflow:
0EA3 0210AC    1531   ljmp StopReflow
0EA6           1532   
0EA6           1533   State0Done:
0EA6 120997    1534       lcall BeepSpeaker
0EA9 755C00    1535       MOV PHASE, #00h
0EAC 755B03    1536       MOV ON_SECS, #3
0EAF 755D14    1537       MOV LEAD, #20
0EB2 0530      1538       inc STATE_VAR_1
0EB4 753C64    1539       mov POWER, #100
0EB7 753A00    1540       mov TIME, #0
0EBA 80D5      1541       sjmp State0
0EBC           1542   State1:
0EBC 30B237    1543       jnb RESET_BUTTON, State1_ResetToMain
0EBF 30B737    1544       jnb STOP_BUTTON, State1_StopReflow
0EC2 E530      1545       mov a, STATE_VAR_1
0EC4 B40148    1546       cjne a, #1, State2
0EC7 C0E0      1547            push acc
0EC9 7401      1547            mov a, #1
0ECB 14        1547            dec a
0ECC 120219    1547            lcall ?Set_Cursor_1 ; Select column and row
0ECF D0E0      1547            pop acc
0ED1 C083      1548            push dph
0ED3 C082      1548            push dpl
0ED5 C0E0      1548            push acc
0ED7 9000C7    1548            mov dptr, #state1_message
0EDA 12020C    1548            lcall ?Send_Constant_String
0EDD D0E0      1548            pop acc
0EDF D082      1548            pop dpl
0EE1 D083      1548            pop dph
0EE3 1209A3    1549       lcall FSM2_Temp_Time_display
0EE6 120F5A    1550       lcall CheckAbortCondition ;Must abort if 50 degrees isn't reached in first 60 seconds
0EE9           1551   
0EE9 854844    1552       mov TARGET, SOAK_TEMP_set
0EEC E535      1553       mov a, TEMP
0EEE C3        1554       clr c
0EEF 9544      1555       subb a, TARGET
0EF1 4009      1556       jc CheckCarryState1 ; C = 1, Keep heating
0EF3 020F02    1557       ljmp GreaterThanState1 ; C = 0, Transition States
0EF6           1558   
0EF6           1559   State1_ResetToMain:
0EF6 0210A3    1560   ljmp ResetToMain
0EF9           1561   
0EF9           1562   State1_StopReflow:
0EF9 0210AC    1563   ljmp StopReflow
0EFC           1564   
0EFC           1565   CheckCarryState1:
0EFC 4002      1566       jc LessThanState1
0EFE 8002      1567       sjmp GreaterThanState1
0F00           1568   LessThanState1:
0F00 80BA      1569       sjmp State1
0F02           1570   GreaterThanState1:
0F02 120997    1571       lcall BeepSpeaker
0F05 0530      1572       inc STATE_VAR_1
0F07 753C14    1573       mov POWER, #20
0F0A 753A00    1574       mov TIME, #0
0F0D 80AD      1575       sjmp State1
0F0F           1576   State2:
0F0F 30B237    1577       jnb RESET_BUTTON, State2_ResetToMain
0F12 30B737    1578       jnb STOP_BUTTON, State2_StopReflow
0F15 E530      1579       mov a, STATE_VAR_1
0F17 B4022C    1580       cjne a, #2, State2_State3
0F1A C0E0      1581            push acc
0F1C 7401      1581            mov a, #1
0F1E 14        1581            dec a
0F1F 120219    1581            lcall ?Set_Cursor_1 ; Select column and row
0F22 D0E0      1581            pop acc
0F24 C083      1582            push dph
0F26 C082      1582            push dpl
0F28 C0E0      1582            push acc
0F2A 9000D8    1582            mov dptr, #state2_message
0F2D 12020C    1582            lcall ?Send_Constant_String
0F30 D0E0      1582            pop acc
0F32 D082      1582            pop dpl
0F34 D083      1582            pop dph
0F36 1209A3    1583       lcall FSM2_Temp_Time_display
0F39 854A46    1584       mov TARGET_TIME, SOAK_TIME_set
0F3C E53A      1585       mov a, TIME
0F3E C3        1586       clr c
0F3F 9546      1587       subb a, TARGET_TIME
0F41 4020      1588       jc CheckCarryState2 ; C = 1, TIME < TARGET_TIME
0F43 020F69    1589       ljmp GreaterThanState2 ; C = 0, TIME > TARGET_TIME -> transition states
0F46           1590   
0F46           1591   State2_State3:
0F46 020F7D    1592       ljmp State3
0F49           1593   
0F49           1594   State2_ResetToMain:
0F49 0210A3    1595   ljmp ResetToMain
0F4C           1596   
0F4C           1597   State2_StopReflow:
0F4C 0210AC    1598   ljmp StopReflow
0F4F           1599   
0F4F           1600   State1_CheckOven:
0F4F E53A      1601   mov a, TIME
0F51 B43C00    1602   cjne a, #60, State1TimeCheckCarry
0F54           1603   
0F54           1604   State1TimeCheckCarry:
0F54 4003      1605   jc TrampolineState1 ; 60 Seconds haven't passed
0F56 0210F0    1606   ljmp STOPOVEN
0F59           1607   
0F59           1608   TrampolineState1:
0F59 22        1609   ret
0F5A           1610   
0F5A           1611   CheckAbortCondition:
0F5A E535      1612       mov a, TEMP
0F5C B43201    1613       cjne a, #50, CheckAbortCarry
0F5F 22        1614       ret
0F60           1615   CheckAbortCarry:
0F60 40ED      1616       jc State1_CheckOven          
0F62 22        1617       ret
0F63           1618   CheckCarryState2:
0F63 4002      1619       jc LessThanState2
0F65 8002      1620       sjmp GreaterThanState2
0F67           1621   LessThanState2:
0F67 80A6      1622       sjmp State2
0F69           1623   GreaterThanState2:
0F69 120997    1624       lcall BeepSpeaker
0F6C 755C00    1625       MOV PHASE, #00h
0F6F 755B03    1626       MOV ON_SECS, #3
0F72 755D0A    1627       MOV LEAD, #10
0F75 0530      1628       inc STATE_VAR_1
0F77 753C64    1629       mov POWER, #100
0F7A 020F0F    1630       ljmp State2
0F7D           1631   State3:
0F7D 30B234    1632       jnb RESET_BUTTON, State3_ResetToMain
0F80 30B734    1633       jnb STOP_BUTTON, State3_StopReflow
0F83 E530      1634       mov a, STATE_VAR_1
0F85 B40345    1635       cjne a, #3, State4
0F88 C0E0      1636            push acc
0F8A 7401      1636            mov a, #1
0F8C 14        1636            dec a
0F8D 120219    1636            lcall ?Set_Cursor_1 ; Select column and row
0F90 D0E0      1636            pop acc
0F92 C083      1637            push dph
0F94 C082      1637            push dpl
0F96 C0E0      1637            push acc
0F98 9000E9    1637            mov dptr, #state3_message
0F9B 12020C    1637            lcall ?Send_Constant_String
0F9E D0E0      1637            pop acc
0FA0 D082      1637            pop dpl
0FA2 D083      1637            pop dph
0FA4 1209A3    1638       lcall FSM2_Temp_Time_display
0FA7 854C44    1639       mov TARGET, reflow_temp_set
0FAA E535      1640       mov a, TEMP
0FAC C3        1641       clr c
0FAD 9544      1642       subb a, TARGET
0FAF 4009      1643       jc CheckCarryState3 ; C = 1, TEMP < TARGET -> Keep Heating
0FB1 020FC0    1644       ljmp GreaterThanState3 ; C = 0, TEMP > TARGET -> Transition States    
0FB4           1645   
0FB4           1646   State3_ResetToMain:
0FB4 0210A3    1647   ljmp ResetToMain
0FB7           1648   
0FB7           1649   State3_StopReflow:
0FB7 0210AC    1650   ljmp StopReflow
0FBA           1651   
0FBA           1652   CheckCarryState3:
0FBA 4002      1653       jc LessThanState3
0FBC 8002      1654       sjmp GreaterThanState3
0FBE           1655   LessThanState3:
0FBE 80BD      1656       sjmp State3
0FC0           1657   GreaterThanState3:
0FC0 120997    1658       lcall BeepSpeaker
0FC3 0530      1659       inc STATE_VAR_1
0FC5 753C14    1660       mov POWER, #20
0FC8 753A00    1661       mov TIME, #0
0FCB 80B0      1662       sjmp State3
0FCD           1663   State4:
0FCD 30B237    1664       jnb RESET_BUTTON, ResetToMainState4
0FD0 30B731    1665       jnb STOP_BUTTON, StopReflowState4
0FD3 E530      1666       mov a, STATE_VAR_1
0FD5 B40442    1667       cjne a, #4, State5
0FD8 C0E0      1668            push acc
0FDA 7401      1668            mov a, #1
0FDC 14        1668            dec a
0FDD 120219    1668            lcall ?Set_Cursor_1 ; Select column and row
0FE0 D0E0      1668            pop acc
0FE2 C083      1669            push dph
0FE4 C082      1669            push dpl
0FE6 C0E0      1669            push acc
0FE8 9000FA    1669            mov dptr, #state4_message
0FEB 12020C    1669            lcall ?Send_Constant_String
0FEE D0E0      1669            pop acc
0FF0 D082      1669            pop dpl
0FF2 D083      1669            pop dph
0FF4 1209A3    1670       lcall FSM2_Temp_Time_display
0FF7 854E46    1671       mov TARGET_TIME, REFLOW_TIME_set
0FFA E53A      1672       mov a, TIME
0FFC C3        1673       clr c
0FFD 9546      1674       subb a, TARGET_TIME
0FFF 4009      1675       jc CheckCarryState4 ; C = 1, TIME < TARGET_TIME -> Keep Going
1001 021010    1676       ljmp GreaterThanState4 ; C = 0, TIME > TARGET_TIME -> Transition States
1004           1677   StopReflowState4:
1004 0210AC    1678       ljmp StopReflow
1007           1679   ResetToMainState4:
1007 0210A3    1680       ljmp ResetToMain
100A           1681   CheckCarryState4:
100A 4002      1682       jc LessThanState4
100C 8002      1683       sjmp GreaterThanState4
100E           1684   LessThanState4:
100E 80BD      1685       sjmp State4 
1010           1686   GreaterThanState4:
1010 120997    1687       lcall BeepSpeaker
1013 0530      1688       inc STATE_VAR_1
1015 753C00    1689       mov POWER, #0
1018 80B3      1690       sjmp State4
101A           1691   State5:
101A 30B233    1692       jnb RESET_BUTTON, ResetToMainState5
101D 30B733    1693       jnb STOP_BUTTON, StopReflowState5
1020 C280      1694       CLR p0.0 ;turn oven off
1022 E530      1695       mov a, STATE_VAR_1    
1024 B4052F    1696       cjne a, #5, State5toDone
1027 853E44    1697       mov TARGET, DEGREES60
102A E535      1698       mov a, TEMP
102C C0E0      1699            push acc
102E 7401      1699            mov a, #1
1030 14        1699            dec a
1031 120219    1699            lcall ?Set_Cursor_1 ; Select column and row
1034 D0E0      1699            pop acc
1036 C083      1700            push dph
1038 C082      1700            push dpl
103A C0E0      1700            push acc
103C 90010B    1700            mov dptr, #state5_message
103F 12020C    1700            lcall ?Send_Constant_String
1042 D0E0      1700            pop acc
1044 D082      1700            pop dpl
1046 D083      1700            pop dph
1048 1209A3    1701       lcall FSM2_Temp_Time_display
104B B43C46    1702       cjne a, #60, CheckCarryState5
104E 80CA      1703       sjmp State5
1050           1704   
1050           1705   ResetToMainState5:
1050 0210A3    1706       ljmp ResetToMain
1053           1707   
1053           1708   StopReflowState5:
1053 0210AC    1709       ljmp StopReflow
1056           1710       
1056           1711   State5toDone:
1056 120997    1712       lcall BeepSpeaker
1059 C0E0      1713            push acc
105B 7401      1713            mov a, #1
105D 14        1713            dec a
105E 120219    1713            lcall ?Set_Cursor_1 ; Select column and row
1061 D0E0      1713            pop acc
1063 C083      1714            push dph
1065 C082      1714            push dpl
1067 C0E0      1714            push acc
1069 90013E    1714            mov dptr, #reflowdone_message
106C 12020C    1714            lcall ?Send_Constant_String
106F D0E0      1714            pop acc
1071 D082      1714            pop dpl
1073 D083      1714            pop dph
1075 C0E0      1715            push acc
1077 7401      1715            mov a, #1
1079 14        1715            dec a
107A 120217    1715            lcall ?Set_Cursor_2 ; Select column and row
107D D0E0      1715            pop acc
107F C083      1716            push dph
1081 C082      1716            push dpl
1083 C0E0      1716            push acc
1085 90014F    1716            mov dptr, #restart_message
1088 12020C    1716            lcall ?Send_Constant_String
108B D0E0      1716            pop acc
108D D082      1716            pop dpl
108F D083      1716            pop dph
1091 021148    1717       ljmp ReflowDone
1094           1718   
1094           1719   CheckCarryState5:
1094 4002      1720       jc LessThanState5
1096 8008      1721       sjmp GreaterThanState5
1098           1722   LessThanState5:
1098 753000    1723       mov STATE_VAR_1, #0
109B C200      1724       clr START_FLAG
109D 02101A    1725       ljmp State5
10A0           1726   GreaterThanState5:
10A0 02101A    1727       ljmp State5
10A3           1728   
10A3           1729   ResetToMain:
10A3 753000    1730       mov STATE_VAR_1, #0
10A6 753C00    1731       mov POWER, #0
10A9 020A32    1732       ljmp MAIN
10AC           1733   
10AC           1734   StopReflow:
10AC D290      1735       setb RED_LED
10AE C0E0      1736            push acc
10B0 7401      1736            mov a, #1
10B2 14        1736            dec a
10B3 120219    1736            lcall ?Set_Cursor_1 ; Select column and row
10B6 D0E0      1736            pop acc
10B8 C083      1737            push dph
10BA C082      1737            push dpl
10BC C0E0      1737            push acc
10BE 900160    1737            mov dptr, #stop_message
10C1 12020C    1737            lcall ?Send_Constant_String
10C4 D0E0      1737            pop acc
10C6 D082      1737            pop dpl
10C8 D083      1737            pop dph
10CA C0E0      1738            push acc
10CC 7401      1738            mov a, #1
10CE 14        1738            dec a
10CF 120217    1738            lcall ?Set_Cursor_2 ; Select column and row
10D2 D0E0      1738            pop acc
10D4 C083      1739            push dph
10D6 C082      1739            push dpl
10D8 C0E0      1739            push acc
10DA 90014F    1739            mov dptr, #restart_message
10DD 12020C    1739            lcall ?Send_Constant_String
10E0 D0E0      1739            pop acc
10E2 D082      1739            pop dpl
10E4 D083      1739            pop dph
10E6 120997    1740       lcall BeepSpeaker
10E9 C280      1741       clr OVEN_PIN ; Turn power off
10EB           1742   ForeverStopped:
10EB 30B257    1743       jnb RESET_BUTTON, RestartProcess
10EE 80FB      1744       sjmp ForeverStopped
10F0           1745   
10F0           1746   STOPOVEN:
10F0 D290      1747       setb RED_LED
10F2 C0E0      1748            push acc
10F4 7401      1748            mov a, #1
10F6 14        1748            dec a
10F7 120219    1748            lcall ?Set_Cursor_1 ; Select column and row
10FA D0E0      1748            pop acc
10FC C083      1749            push dph
10FE C082      1749            push dpl
1100 C0E0      1749            push acc
1102 90011C    1749            mov dptr, #abortcondition_message
1105 12020C    1749            lcall ?Send_Constant_String
1108 D0E0      1749            pop acc
110A D082      1749            pop dpl
110C D083      1749            pop dph
110E C0E0      1750            push acc
1110 7401      1750            mov a, #1
1112 14        1750            dec a
1113 120217    1750            lcall ?Set_Cursor_2 ; Select column and row
1116 D0E0      1750            pop acc
1118 C083      1751            push dph
111A C082      1751            push dpl
111C C0E0      1751            push acc
111E 90014F    1751            mov dptr, #restart_message
1121 12020C    1751            lcall ?Send_Constant_String
1124 D0E0      1751            pop acc
1126 D082      1751            pop dpl
1128 D083      1751            pop dph
112A 7C0A      1752       mov R4, #10
112C           1753   STOPOVENSpeakerLoop:
112C 120997    1754       lcall BeepSpeaker
112F 12069A    1755       lcall Wait50ms
1132 12069A    1756       lcall Wait50ms
1135 12069A    1757       lcall Wait50ms
1138 12069A    1758       lcall Wait50ms
113B 12069A    1759       lcall Wait50ms
113E DCEC      1760       djnz R4, STOPOVENSpeakerLoop
1140           1761   ForeverStop:
1140 30B202    1762       jnb RESET_BUTTON, RestartProcess
1143 80FB      1763       sjmp ForeverStop ; Infinite loop to stop the oven if abort condition is met
1145           1764   
1145           1765   RestartProcess:
1145 020A32    1766       ljmp MAIN
1148           1767       
1148           1768   ReflowDone:
1148 D2B1      1769       setb GREEN_LED
114A 7C05      1770       mov R4, #5
114C           1771   SpeakerLoop:
114C 120997    1772       lcall BeepSpeaker
114F 12069A    1773       lcall Wait50ms
1152 12069A    1774       lcall Wait50ms
1155 12069A    1775       lcall Wait50ms
1158 12069A    1776       lcall Wait50ms
115B 12069A    1777       lcall Wait50ms
115E DCEC      1778       djnz R4, SpeakerLoop
1160           1779   Forever:
1160 30B202    1780       jnb RESET_BUTTON, ForeverToMain
1163 80FB      1781       sjmp Forever
1165           1782   ForeverToMain:
1165 0210A3    1783            ljmp ResetToMain
1168           1784   END
