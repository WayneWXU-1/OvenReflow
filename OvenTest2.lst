                  2   $LIST
0000              4   
0000              5   CLK           EQU 33333333 ; Microcontroller system crystal frequency in Hz
0000              6   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000              7   TIMER0_RELOAD EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 is always 12 unlike the N76E003 where is selectable.
0000              8   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0000              9   TIMER2_RELOAD EQU ((65536-(CLK/(12*TIMER2_RATE))))
0000             10   BAND          EQU 2 ;for flat states
0000             11   LEAD2              EQU 4 ;a too close overshoots currently
0000             12   LEAD          EQU 20 ;for ramp sates
0000             13   
0000             14   BAUD   EQU 57600
0000             15   T1_LOAD EQU 256-(2*CLK) / (32*12*BAUD) ;Load 253 so it counts 3 counts before overflowing, which gives us a 57600 baud rate with a 33.333MHz clock
0000             16   
0000             17   
0000             18   ; ********* Buttons ***********
0000             19   SELECT_BUTTON equ P3_4 ; middle left
0000             20   RESET_BUTTON  equ KEY_1
0000             21   START_BUTTON  equ P3_5 ; middle right
0000             22   STOP_BUTTON   equ P3_7 ; right 
0000             23   PARAM_BUTTON  equ P3_3 ; left
0000             24   
0000             25   OVEN_PIN      equ P0.0
0000             26   SOUND_OUT     equ P1.5 ; Speaker attached to this pin
0000             27   UPDOWN        equ SWA.0
0000             28   TENS          equ SWA.1
0000             29   
0000             30   ; Reset vector
0000             31   org 0x0000
0000 0209E0      32       ljmp MAIN
0003             33   
0003             34   ; External interrupt 0 vector (not used in this code)
0003             35   org 0x0003
0003 32          36            reti
0004             37   
0004             38   ; Timer/Counter 0 overflow interrupt vector
000B             39   org 0x000B
000B 02058C      40            ljmp Timer0_ISR
000E             41   
000E             42   ; External interrupt 1 vector (not used in this code)
0013             43   org 0x0013
0013 32          44            reti
0014             45   
0014             46   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             47   org 0x001B
001B 32          48            reti
001C             49   
001C             50   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             51   org 0x0023 
0023 32          52            reti
0024             53            
0024             54   ; Timer/Counter 2 overflow interrupt vector
002B             55   org 0x002B
002B 0205AE      56            ljmp Timer2_ISR
002E             57   
002E             58   
002E             59   ;--- DATA RAM ---
0030             60   dseg at 0x30
0030             61   STATE_VAR_1:     DS 1 
0031             62   STATE_VAR_2:     DS 1
0032             63   SECOND_COUNTER:  DS 1 
0033             64   TEMP_HIGH_BYTE:  DS 1 
0034             65   TEMP_LOW_BYTE:   DS 1 
0035             66   
0035             67   
0035             68   TEMP:            DS 5
003A             69   TIME:            DS 2
003C             70   POWER:           DS 2
003E             71   DEGREES60:       DS 2
0040             72   DEGREES150:      DS 2
0042             73   DEGREES220:      DS 2
0044             74   TARGET:          DS 2
0046             75   TARGET_TIME:     DS 2
0048             76   ;*** Variables ***
0048             77   SOAK_TEMP_set:       ds 2
004A             78   SOAK_TIME_set:       ds 2
004C             79   reflow_temp_set:     ds 2
004E             80   REFLOW_TIME_set:     ds 2
0050             81   
0050             82   soak_time:       ds 2
0052             83   REFLOW_TIME:     ds 2
0054             84   
0054             85   beep_count:      ds 1
0055             86   
0055             87   ; PWM variables
0055             88   LOW_LIMIT:  ds 2
0057             89   HIGH_LIMIT: ds 2
0059             90   THRESHOLD:  ds 2
005B             91   
005B             92   x:               ds      4 ;used for 32 bit math for temperature conversion
005F             93   y:               ds      4 ;used for 32 bit math for temperature conversion
0063             94   bcd:    ds  5 ; <--- ADD THIS: math32 needs 5 bytes for BCD conversions
0068             95   
0068             96   ;--ISR RELATED--;
0068             97   Count1ms:     ds 2 ; Used to determine when half second has passed
006A             98   BCD_counter:  ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
006B             99   
006B            100   
006B            101   ; **** keypad variables ****
006B            102   keypad_digit_count: ds 1
006C            103   
006C            104   
0000            105   bseg
0000            106   START_FLAG:         DBIT 1  ; Use DBIT for single bits in bseg
0001            107   half_seconds_flag:  DBIT 1  ; half second flag
0002            108   SECONDS_FLAG:       DBIT 1  ; can change later depending on how fast we want it
0003            109   SELECT_BUTTON_FLAG: DBIT 1
0004            110   PARAM_BUTTON_FLAG:  DBIT 1
0005            111   KEYPAD_FLAG:        DBIT 1
0006            112   mf:     dbit 1 ; <--- ADD THIS: math32 uses this as a status flag
0007            113   
002E            114   cseg
002E            115   ; These 'equ' must match the hardware wiring
002E            116   ; None of these are implemented yet, we need to match these assignments to the wiring
002E            117   ELCD_RS equ P1.7
002E            118   ;LCD_RW equ PX.X ; Not used in this code, connect the pin to GND
002E            119   ELCD_E equ  P1.1
002E            120   ELCD_D4 equ P0.7
002E            121   ELCD_D5 equ P0.5
002E            122   ELCD_D6 equ P0.3
002E            123   ELCD_D7 equ P0.1
002E            124   
002E            125   ;Keypad pin assignments
002E            126   ROW1 EQU P1.2
002E            127   ROW2 EQU P1.4
002E            128   ROW3 EQU P1.6
002E            129   ROw4 EQU P2.0
002E            130   COL1 EQU P2.2
002E            131   COL2 EQU P2.4
002E            132   COL3 EQU P2.6
002E            133   COL4 EQU P3.0
002E            134   
002E            135   ;                           1234567890123456
002E 20202020   136   blank_row:              db '                ', 0
     20202020
     20202020
     20202020
     00
003F 53656C65   137   param_message:          db 'Select Parameter', 0
     63742050
     6172616D
     65746572
     00
0050 536F616B   138   soak_temp_message:      db 'Soak Temp: xxx C', 0
     2054656D
     703A2078
     78782043
     00
0061 536F616B   139   soak_time_message:      db 'Soak Time: xx  s', 0
     2054696D
     653A2078
     78202073
     00
0072 52666C77   140   reflow_temp_message:    db 'Rflw Temp: xxx C', 0
     2054656D
     703A2078
     78782043
     00
0083 52666C77   141   reflow_time_message:    db 'Rflw Time: xx  s', 0
     2054696D
     653A2078
     78202073
     00
0094 52656164   142   ready_message:          db 'Ready to Start! ', 0
     7920746F
     20537461
     72742120
     00
00A5 2D2D2D2D   143   state0_message:         db '-----State0-----', 0
     2D537461
     7465302D
     2D2D2D2D
     00
00B6 2D2D2D2D   144   state1_message:         db '-----State1-----', 0
     2D537461
     7465312D
     2D2D2D2D
     00
00C7 2D2D2D2D   145   state2_message:         db '-----State2-----', 0
     2D537461
     7465322D
     2D2D2D2D
     00
00D8 2D2D2D2D   146   state3_message:         db '-----State3-----', 0
     2D537461
     7465332D
     2D2D2D2D
     00
00E9 2D2D2D2D   147   state4_message:         db '-----State4-----', 0
     2D537461
     7465342D
     2D2D2D2D
     00
00FA 2D2D2D2D   148   state5_message:         db '-----State5-----', 0
     2D537461
     7465352D
     2D2D2D2D
     00
010B 2A2A2A2A   149   abortcondition_message: db '*****ABORT!*****', 0
     2A41424F
     5254212A
     2A2A2A2A
     00
011C 54494D45   150   reflow_message:         db 'TIME:XXXTEMP:XXX', 0
     3A585858
     54454D50
     3A585858
     00
012D 5265666C   151   reflowdone_message:     db 'Reflow Complete!', 0
     6F772043
     6F6D706C
     65746521
     00
013E 52535420   152   restart_message:        db 'RST 2 Bake Again', 0
     32204261
     6B652041
     6761696E
     00
014F            153   
014F 5265666C   154   stop_message:           db 'Reflow Stopped! ', 0
     6F772053
     746F7070
     65642120
     00
0160            155   
0160 54494D45   156   TimeLabel: db 'T','I','M','E',':', 0
     3A00
0166 54454D50   157   TempLabel: db 'T','E','M','P',':', 0
     3A00
016C            158   
                160   	$LIST
0223            162   
                614   $LIST
                165   $LIST
0515            167   
0515            168   ;-----------------------INTIALIZE SERIAL PORT FOR INPUT OUTUUT-----------------------;
0515            169   ;--Setting baud rate to 57600 with 33.33MHz clock--;
0515            170   ;-----------EXPLANATION------------
0515            171   ;Crystal oscillates at 33.33Mhz, the CV-8052 has a fixed prescaler of 12 for timers
0515            172   ;So the effective clock for timers is 33.33MHz/12 = 2.7775MHzl
0515            173   ;SMOD is set to 1 in PCON so using 1/16th the clock for baud rate generation
0515            174   ;That means the baud rate clock is 2.7775MHz/16 = 173.611kHz
0515            175   ;Since we have 253 out of 256 its three clicks 
0515            176   ;per bit, the baud rate is 173.611kHz/3 = 57.870kbps which is close enough to 57600bps
0515            177   ;-----------------------------------
0515            178   
0515            179   InitSerialPort:
0515            180            ; Configure serial port and baud rate
0515 C28E       181       clr TR1 ; Disable timer 1
0517 E589       182       mov a, TMOD
0519 540F       183       anl a, #0x0f ; Clear the bits for timer 1
051B 4420       184       orl a, #0x20 ; Configure timer 1 as 8-bit autoreload
051D F589       185       mov TMOD, a ; Set timer 1 mode
051F            186   
051F 758DFD     187       mov TH1, #T1_LOAD ; Load the timer value for the desired baud rate
0522 758BFD     188       mov TL1, #T1_LOAD ;Doesnt matter what we load in TL1 because it is in autoreload mode, but we need to load it with something to prevent it from overflowing immediately
0525            189       ;Leave it as you found it, make SMOD = 1 for double baud rate
0525 E587       190       mov a, PCON ; Set SMOD to 1
0527 4480       191       orl a, #0x80
0529 F587       192       mov PCON, a
052B D28E       193       setb TR1 ; Enable timer 1
052D 759852     194       mov SCON, #01010010B ; Mode 1, 8-bit UART, enable receiver
0530 22         195            ret
0531            196   
0531            197   Display_Voltage_Serial:
0531 85355B     198            mov x+0, TEMP+0 ; reloads the temp into x which will be converted to bcd
0534 85365C     199       mov x+1, TEMP+1
0537 755D00     200       mov x+2, #0
053A 755E00     201       mov x+3, #0
053D 120223     202       lcall hex2bcd ; standard math32.asm function
0540            203       
0540 7454       204            mov a, #'T'
0542 120571     205            lcall putchar
0545 743D       206            mov a, #'='
0547 120571     207            lcall putchar
054A            208            
054A E564       209            mov a, bcd+1
054C 540F       210            anl a, #0FH
054E 4430       211            orl a, #'0'
0550 120571     212            lcall putchar
0553            213   
0553 E563       214            mov a, bcd+0
0555 C4         215            swap a
0556 540F       216            anl a, #0FH
0558 4430       217            orl a, #'0'
055A 120571     218            lcall putchar
055D            219            
055D E563       220            mov a, bcd+0
055F 540F       221            anl a, #0FH
0561 4430       222            orl a, #'0'
0563 120571     223            lcall putchar
0566            224   
0566 740D       225            mov a, #'\r'
0568 120571     226            lcall putchar
056B 740A       227            mov a, #'\n'
056D 120571     228            lcall putchar
0570            229            
0570 22         230            ret
0571            231   
0571            232   
0571            233   
0571            234   ; Function to stransmit accumulator value into the serial buffer register after previous completion
0571            235   putchar:
0571 3099FD     236       jnb TI, putchar ; TI is the transmit interrupt, it will loop until it is high and we know the previous bit is sent
0574            237       
0574 C299       238       clr TI  ; Reset back to 0 to indicate we are transmitting 
0576 F599       239       mov SBUF, a ; accumulator will have output chharacter already stored on it
0578 22         240       ret
0579            241   
0579            242   
0579            243   ; ******************************* TIMER ISRS ************************************
0579            244   
0579            245   Timer0_Init:
0579 E589       246            mov a, TMOD
057B 54F0       247            anl a, #0xf0 ; Clear the bits for timer 0
057D 4401       248            orl a, #0x01 ; Configure timer 0 as 16-timer
057F F589       249            mov TMOD, a
0581 758CFD     250            mov TH0, #high(TIMER0_RELOAD)
0584 758A5A     251            mov TL0, #low(TIMER0_RELOAD)
0587            252            ; Enable the timer and interrupts
0587 D2A9       253       setb ET0  ; Enable timer 0 interrupt
0589 D28C       254       setb TR0  ; Start timer 0
058B 22         255            ret
058C            256   
058C            257   ;---------------------------------;
058C            258   ; ISR for timer 0.  Set to execute;
058C            259   ; every 1/4096Hz to generate a    ;
058C            260   ; 2048 Hz square wave at pin P1.5 ;
058C            261   ;---------------------------------;
058C            262   Timer0_ISR:
058C            263            ;clr TF0  ; According to the data sheet this is done for us already.
058C 758CFD     264            mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
058F 758A5A     265            mov TL0, #low(TIMER0_RELOAD)
0592 B295       266            cpl SOUND_OUT ; Connect speaker to P1.5
0594 32         267            reti
0595            268   
0595            269   ;---------------------------------;
0595            270   ; Routine to initialize the ISR   ;
0595            271   ; for timer 2                     ;
0595            272   ;---------------------------------;
0595            273   Timer2_Init:
0595 75C800     274            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
0598 75CDF5     275            mov TH2, #high(TIMER2_RELOAD)
059B 75CC27     276            mov TL2, #low(TIMER2_RELOAD)
059E            277            ; Set the reload value
059E 75CBF5     278            mov RCAP2H, #high(TIMER2_RELOAD)
05A1 75CA27     279            mov RCAP2L, #low(TIMER2_RELOAD)
05A4            280            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
05A4 E4         281            clr a
05A5 F568       282            mov Count1ms+0, a
05A7 F569       283            mov Count1ms+1, a
05A9            284            ; Enable the timer and interrupts
05A9 D2AD       285       setb ET2  ; Enable timer 2 interrupt
05AB D2CA       286       setb TR2  ; Enable timer 2
05AD 22         287            ret
05AE            288   
05AE            289   ;---------------------------------;
05AE            290   ; ISR for timer 2                 ;
05AE            291   ;---------------------------------;
05AE            292   Timer2_ISR:
05AE C2CF       293            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
05B0            294            
05B0            295            ; The two registers used in the ISR must be saved in the stack
05B0 C0E0       296            push acc
05B2 C0D0       297            push psw
05B4            298            
05B4            299            ; Increment the 16-bit one mili second counter
05B4 0568       300            inc Count1ms+0    ; Increment the low 8-bits first
05B6 E568       301            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
05B8 7002       302            jnz Inc_Done
05BA 0569       303            inc Count1ms+1 ;increment high 8-bits if low 8-bits overflowed
05BC            304   
05BC            305   Inc_Done:
05BC            306            ; Check if full second has passed
05BC E568       307            mov a, Count1ms+0
05BE B4E86D     308            cjne a, #low(1000), Timer2_ISR_Midpoint ; Warning: this instruction changes the carry flag!
05C1 E569       309            mov a, Count1ms+1
05C3 B40368     310            cjne a, #high(1000), Timer2_ISR_Midpoint
05C6            311       
05C6            312       
05C6            313       
05C6            314       
05C6 75A100     315            mov ADC_C, #00000000b
05C9            316            
05C9            317   
05C9 755E00     318       mov x+3, #0
05CC 755D00     319            mov x+2, #0
05CF 85A35C     320            mov x+1, ADC_H
05D2 85A25B     321            mov x+0, ADC_L
05D5            322       ; Convert ADC reading to temperature in Celsius
05D5            323       ; Voltage = (ADC_value * 5000) / 4096
05D5 755F88     324            mov y+0, #low (5000 % 0x10000) 
05D8 756013     324            mov y+1, #high(5000 % 0x10000) 
05DB 756100     324            mov y+2, #low (5000 / 0x10000) 
05DE 756200     324            mov y+3, #high(5000 / 0x10000) 
05E1            324   
05E1 120381     325            lcall mul32
05E4 755F00     326            mov y+0, #low (4096 % 0x10000) 
05E7 756010     326            mov y+1, #high(4096 % 0x10000) 
05EA 756100     326            mov y+2, #low (4096 / 0x10000) 
05ED 756200     326            mov y+3, #high(4096 / 0x10000) 
05F0 120475     327            lcall div32
05F3            328       ; Result is in 'x'
05F3            329   
05F3 755FE8     330            mov y+0, #low (1000 % 0x10000) 
05F6 756003     330            mov y+1, #high(1000 % 0x10000) 
05F9 756100     330            mov y+2, #low (1000 / 0x10000) 
05FC 756200     330            mov y+3, #high(1000 / 0x10000)  ; convert to microvolts
05FF 120381     331       lcall mul32
0602 755F0C     332            mov y+0, #low (12300 % 0x10000) 
0605 756030     332            mov y+1, #high(12300 % 0x10000) 
0608 756100     332            mov y+2, #low (12300 / 0x10000) 
060B 756200     332            mov y+3, #high(12300 / 0x10000)  ; 41 * 300
060E 120475     333       lcall div32
0611            334   
0611 755F16     335            mov y+0, #low (22 % 0x10000) 
0614 756000     335            mov y+1, #high(22 % 0x10000) 
0617 756100     335            mov y+2, #low (22 / 0x10000) 
061A 756200     335            mov y+3, #high(22 / 0x10000)  ; add cold junction temperature
061D 1202C8     336       lcall add32
0620            337       ;do your displays and stuff
0620            338       ;result is still in x
0620 855B35     339       mov TEMP+0, x+0
0623 855C36     340       mov TEMP+1, x+1
0626            341       
0626 120531     342       lcall Display_Voltage_Serial
0629 120898     343       lcall Display_BCD_7_seg
062C            344   
062C 8003       345       sjmp Timer2_ISR_Bypass
062E            346   
062E            347   Timer2_ISR_Midpoint:
062E 020671     348   ljmp Timer2_ISR_done
0631            349   Timer2_ISR_Bypass:
0631            350   
0631            351   ;---------------------------------------------------------------------;
0631            352            
0631            353            ;1 second have passed.  Set a flag so the main program knows
0631 D202       354            setb seconds_flag ; Let the main program know one second had passed
0633            355            ; Toggle LEDR0 so it blinks
0633 053A       356       inc TIME ; Increment the TIME Variable
0635 B2E8       357            cpl LEDRA.0
0637 E4         358            clr a
0638 F568       359            mov Count1ms+0, a
063A F569       360            mov Count1ms+1, a
063C            361       
063C            362       ;Call PWM funcions
063C            363   Checkforstate1:
063C E530       364       MOV A, STATE_VAR_1
063E B40105     365       CJNE A, #1, NOT_STATE_1
0641 12090D     366       LCALL pwm_for_ramp
0644 8016       367       SJMP PWM_EXIT
0646            368   NOT_STATE_1:
0646 B40305     369       CJNE A, #3, NOT_STATE_3
0649 120929     370       LCALL pwm_for_ramp2
064C 800E       371       SJMP PWM_EXIT
064E            372   NOT_STATE_3:
064E B40205     373       CJNE A, #2, NOT_STATE_2
0651 1208E1     374       LCALL pwm_for_flatstates
0654 8006       375       SJMP PWM_EXIT
0656            376   NOT_STATE_2:
0656 B40403     377       CJNE A, #4, PWM_EXIT     ; If not 4, do nothing and exit
0659 1208E1     378       LCALL pwm_for_flatstates
065C            379   PWM_EXIT:
065C            380   
065C            381   
065C            382       
065C            383            ; Increment the BCD counter
065C E56A       384            mov a, BCD_counter
065E 20E80B     385            jb UPDOWN, Timer2_ISR_decrement
0661 2401       386            add a, #0x01; Increment the BCD counter
0663 E56A       387            mov a, BCD_counter
0665 20E804     388            jb UPDOWN, Timer2_ISR_decrement
0668 2401       389            add a, #0x01
066A 8002       390            sjmp Timer2_ISR_da
066C            391   Timer2_ISR_decrement:
066C 2499       392            add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.
066E            393   Timer2_ISR_da:
066E D4         394            da a ; Decimal adjust instruction.  Check datasheet for more details!
066F F56A       395            mov BCD_counter, a
0671            396   
0671            397            
0671            398   Timer2_ISR_done:
0671 D0D0       399            pop psw
0673 D0E0       400            pop acc
0675 32         401            reti
0676            402   
0676            403   INITIALIZE:
0676            404   
0676 759AAB     405            mov P0MOD, #10101011b ; P0.0(OVEN_PIN), P0.1, P0.3, P0.5, P0.7(LCD) are outputs. 
0679 759BF6     406       mov P1MOD, #11110110b ; P1.7, P1.5, P1.1(LCD), 1.2, 1.4, 1.6(ROW) are outputs
067C 759C01     407       mov P2MOD, #00000001b ; output: 2.0(ROW) input: 2.2, 2.4, 2.6(COL)
067F 759D00     408       mov P3MOD, #00000000b ; input: 3.0 (COL), 3.3, 3.4, 3.5, 3.7 
0682            409       ; for keypad, (ROWS as output-1)1.2, 1.4, 1.6, 2.0 - (COLS as input-0) 2.2, 2.4, 2.6, 3.0
0682 75A100     410       mov ADC_C, #0x00      ; Select ADC Channel 0
0685 75A180     411       mov ADC_C, #10000000b ; ADC Enable = 1 test******
0688 22         412       ret                   ; Added RET so it doesn't crash after initializing
0689            413   
0689            414   ; ************************** FUNCTIONS ***********************************
0689            415   
0689            416   Wait50ms:
0689            417   ;33.33MHz, 1 clk per cycle: 0.03us
0689 781E       418            mov R0, #30
068B            419   Wait50ms_L3:
068B 794A       420            mov R1, #74
068D            421   Wait50ms_L2:
068D 7AFA       422            mov R2, #250
068F            423   Wait50ms_L1:
068F DAFE       424            djnz R2, Wait50ms_L1 ;3*250*0.03us=22.5us
0691 D9FA       425       djnz R1, Wait50ms_L2 ;74*22.5us=1.665ms
0693 D8F6       426       djnz R0, Wait50ms_L3 ;1.665ms*30=50ms
0695 22         427       ret
0696            428   
0696            429   
0696            430   ; **************************** KEYPAD *******************************
0696            431   
0696            432   myLUT:
0696 C0F9A4B0   433       DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
     99
069B 9282F880   434       DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
     90
06A0 8883C6A1   435       DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F
     868E
06A6            436   
                437   showBCD MAC
                438   	; Display LSD
                439       mov A, %0
                440       anl a, #0fh
                441       movc A, @A+dptr
                442       mov %1, A
                443   
                444   	; Display MSD
                445       mov A, %0
                446       swap a
                447       anl a, #0fh
                448       movc A, @A+dptr
                449       mov %2, A
                450   ENDMAC
06A6            451   
06A6            452   Display:
06A6 900696     453            mov dptr, #myLUT
                453   	$MESSAGE TIP: If digits 10, 9, 8, and 7 are not zero, LEDR7: on
06A9            455   
06A9 E566       456            mov a, bcd+3
06AB 4567       457            orl a, bcd+4
06AD 6004       458            jz Display_L1
06AF D2EF       459            setb LEDRA.7 ; Non-zero digits alert
06B1 8002       460            sjmp Display_L2
06B3            461   
06B3            462   Display_L1:
06B3 C2EF       463            clr LEDRA.7
06B5            464   
06B5            465   Display_L2:
                465   	$MESSAGE TIP: Pressing KEY3, displays the most significant digits of the 10-digit number
06B5            467   
06B5 30FB2F     468            jnb key.3, Display_high_digits
06B8            469            ; Display LSD
06B8 E563       469       mov A, bcd+0
06BA 540F       469       anl a, #0fh
06BC 93         469       movc A, @A+dptr
06BD F591       469       mov HEX0, A
06BF            469   
06BF            469            ; Display MSD
06BF E563       469       mov A, bcd+0
06C1 C4         469       swap a
06C2 540F       469       anl a, #0fh
06C4 93         469       movc A, @A+dptr
06C5 F592       469       mov HEX1, A
06C7            470            ; Display LSD
06C7 E564       470       mov A, bcd+1
06C9 540F       470       anl a, #0fh
06CB 93         470       movc A, @A+dptr
06CC F593       470       mov HEX2, A
06CE            470   
06CE            470            ; Display MSD
06CE E564       470       mov A, bcd+1
06D0 C4         470       swap a
06D1 540F       470       anl a, #0fh
06D3 93         470       movc A, @A+dptr
06D4 F594       470       mov HEX3, A
06D6            471            ; Display LSD
06D6 E565       471       mov A, bcd+2
06D8 540F       471       anl a, #0fh
06DA 93         471       movc A, @A+dptr
06DB F58E       471       mov HEX4, A
06DD            471   
06DD            471            ; Display MSD
06DD E565       471       mov A, bcd+2
06DF C4         471       swap a
06E0 540F       471       anl a, #0fh
06E2 93         471       movc A, @A+dptr
06E3 F58F       471       mov HEX5, A
06E5            472   
06E5 8024       473            sjmp Display_end
06E7            474   
06E7            475   Display_high_digits:
06E7            476            ; Display LSD
06E7 E566       476       mov A, bcd+3
06E9 540F       476       anl a, #0fh
06EB 93         476       movc A, @A+dptr
06EC F591       476       mov HEX0, A
06EE            476   
06EE            476            ; Display MSD
06EE E566       476       mov A, bcd+3
06F0 C4         476       swap a
06F1 540F       476       anl a, #0fh
06F3 93         476       movc A, @A+dptr
06F4 F592       476       mov HEX1, A
06F6            477            ; Display LSD
06F6 E567       477       mov A, bcd+4
06F8 540F       477       anl a, #0fh
06FA 93         477       movc A, @A+dptr
06FB F593       477       mov HEX2, A
06FD            477   
06FD            477            ; Display MSD
06FD E567       477       mov A, bcd+4
06FF C4         477       swap a
0700 540F       477       anl a, #0fh
0702 93         477       movc A, @A+dptr
0703 F594       477       mov HEX3, A
0705 758EFF     478            mov HEX4, #0xff         
0708 758FFF     479            mov HEX5, #0xff         
070B            480   
070B            481   Display_end:
070B 22         482       ret
070C            483   
070C            484   
                485   MYRLC MAC
                486   	mov a, %0
                487   	rlc a
                488   	mov %0, a
                489   ENDMAC
070C            490   
070C            491   Shift_Digits_Left:
070C 7804       492            mov R0, #4 ; shift left four bits
070E B4031B     493       cjne a, #3, Shift_Digits_Left_L0
0711 22         494   ret
0712            495   
0712 E531       496       mov a, STATE_VAR_2
0714 B40006     497       cjne a, #0, KCheck_StateC
0717            498   
0717 E56B       499       mov a, keypad_digit_count
0719 B40310     500       cjne a, #3, Shift_Digits_Left_L0
071C            501   
071C 22         502       ret
071D            503   
071D            504   KCheck_StateC:
071D B40206     505       cjne a, #2, KCheck_Time_States
0720 E56B       506       mov a, keypad_digit_count
0722 B40307     507       cjne a, #3, Shift_Digits_Left_L0
0725 22         508       ret
0726            509   
0726            510   KCheck_Time_States:
0726 E56B       511       mov a, keypad_digit_count
0728 B40201     512       cjne a, #2, Shift_Digits_Left_L0
072B 22         513       ret
072C            514   
072C            515   Shift_Digits_Left_L0:
072C C3         516            clr c
072D E563       517            mov a, bcd+0
072F 33         517            rlc a
0730 F563       517            mov bcd+0, a
0732 E564       518            mov a, bcd+1
0734 33         518            rlc a
0735 F564       518            mov bcd+1, a
0737 E565       519            mov a, bcd+2
0739 33         519            rlc a
073A F565       519            mov bcd+2, a
073C E566       520            mov a, bcd+3
073E 33         520            rlc a
073F F566       520            mov bcd+3, a
0741 E567       521            mov a, bcd+4
0743 33         521            rlc a
0744 F567       521            mov bcd+4, a
0746            522   
0746 D8E4       523            djnz R0, Shift_Digits_Left_L0
0748            524            ; R7 has the new bcd digit      
0748 EF         525            mov a, R7
0749 4563       526            orl a, bcd+0
074B F563       527            mov bcd+0, a
074D            528   
074D 056B       529       inc keypad_digit_count
074F D3         530       setb c
0750            531       
0750            532   Shift_Digits_left_exit:
0750 22         533            ret
0751            534   
0751            535            
                536   MYRRC MAC
                537   	mov a, %0
                538   	rrc a
                539   	mov %0, a
                540   ENDMAC
0751            541   
0751            542   Shift_Digits_Right:
0751 7804       543            mov R0, #4 ; shift right four bits
0753            544   
0753            545   Shift_Digits_Right_L0:
0753 C3         546            clr c
0754 E567       547            mov a, bcd+4
0756 13         547            rrc a
0757 F567       547            mov bcd+4, a
0759 E566       548            mov a, bcd+3
075B 13         548            rrc a
075C F566       548            mov bcd+3, a
075E E565       549            mov a, bcd+2
0760 13         549            rrc a
0761 F565       549            mov bcd+2, a
0763 E564       550            mov a, bcd+1
0765 13         550            rrc a
0766 F564       550            mov bcd+1, a
0768 E563       551            mov a, bcd+0
076A 13         551            rrc a
076B F563       551            mov bcd+0, a
076D            552   
076D D8E4       553            djnz R0, Shift_Digits_Right_L0
076F            554   
076F E56B       555       mov a, keypad_digit_count
0771 6003       556       jz Shift_Digits_Right_Ret
0773 156B       557       dec keypad_digit_count
0775            558   
0775 D3         559       setb c
0776            560   
0776            561   Shift_Digits_Right_Ret:
0776 22         562            ret
0777            563   
0777            564   
0777            565   Wait25ms:
0777            566   ;33.33MHz, 1 clk per cycle: 0.03us
0777 780F       567            mov R0, #15
0779 794A       568   LL3: mov R1, #74
077B 7AFA       569   LL2: mov R2, #250
077D DAFE       570   LL1: djnz R2, LL1 ;3*250*0.03us=22.5us
077F D9FA       571        djnz R1, LL2 ;74*22.5us=1.665ms
0781 D8F6       572        djnz R0, LL3 ;1.665ms*15=25ms
0783            573   
0783 22         574       ret
0784            575   
0784            576   
0784            577   
                578   CHECK_COLUMN MAC
                579   	jb %0, CHECK_COL_%M
                580   	mov R7, %1
                581   	jnb %0, $ ; wait for key release
                582   	setb c
                583   	ret
                584   CHECK_COL_%M:
                585   ENDMAC
0784            586   
0784            587   Configure_Keypad_Pins:
0784            588            ; Configure the row pins as output and the column pins as inputs
0784 439B54     589            orl P1MOD, #0b_01010100 ; P1.6, P1.4, P1.2 output
0787 439C01     590            orl P2MOD, #0b_00000001 ; P2.0 output
078A 539CAB     591            anl P2MOD, #0b_10101011 ; P2.6, P2.4, P2.2 input
078D 539DFE     592            anl P3MOD, #0b_11111110 ; P3.0 input
0790 22         593            ret
0791            594   
0791            595   ; This subroutine scans a 4x4 keypad.  If a key is pressed sets the carry
0791            596   ; to one and returns the key code in register R7.
0791            597   ; It works with both a default keypad or a modified keypad with the labels
0791            598   ; rotated 90 deg ccw.  The type of keypad is determined by SW0, which is bit SWA.0
0791            599   
0791            600   Keypad:
0791            601            ; First check the backspace/correction pushbutton.  We use KEY1 for this function.
                601   	$MESSAGE TIP: KEY1 is the erase key
0791            603   
0791 20B717     604            jb STOP_BUTTON, keypad_L0
0794 120777     605            lcall Wait25ms ; debounce
0797 20B711     606            jb STOP_BUTTON, keypad_L0
079A            607   
079A 30B7FD     608            jnb STOP_BUTTON, $ ; The key was pressed, wait for release
079D 120751     609            lcall Shift_Digits_Right
07A0 120270     610       lcall bcd2hex
07A3 855B48     611       mov soak_temp_set+0, x+0
07A6 855C49     612       mov soak_temp_set+1, x+1
07A9 C3         613            clr c
07AA 22         614            ret
07AB            615   
07AB            616   keypad_L0:
07AB            617   
07AB            618            ; Make all the rows zero.  If any column is zero then a key is pressed.
07AB C292       619            clr ROW1
07AD C294       620            clr ROW2
07AF C296       621            clr ROW3
07B1 C2A0       622            clr ROW4
07B3            623   
07B3 A2A2       624            mov c, COL1
07B5 82A4       625            anl c, COL2
07B7 82A6       626            anl c, COL3
07B9 82B0       627            anl c, COL4
07BB            628   
07BB 5002       629            jnc Keypad_Debounce
07BD C3         630            clr c
07BE 22         631            ret
07BF            632   
07BF            633   
07BF            634   Keypad_Debounce:
07BF            635            ; A key maybe pressed.  Wait and check again to discard bounces.
07BF 120777     636            lcall Wait25ms ; debounce
07C2            637   
07C2 A2A2       638            mov c, COL1
07C4 82A4       639            anl c, COL2
07C6 82A6       640            anl c, COL3
07C8 82B0       641            anl c, COL4
07CA            642   
07CA 5002       643            jnc Keypad_Key_Code
07CC C3         644            clr c
07CD 22         645            ret
07CE            646            
07CE            647   
07CE            648   Keypad_Key_Code:         
07CE            649            ; A key is pressed.  Find out which one by checking each possible column and row combination.
07CE            650   
07CE D292       651            setb ROW1
07D0 D294       652            setb ROW2
07D2 D296       653            setb ROW3
07D4 D2A0       654            setb ROW4
07D6            655   
07D6            656            ; This check section is for an un-modified keypad
07D6            657   
07D6            658   keypad_default:  
07D6            659   
07D6            660            ; Check row 1   
07D6 C292       661            clr ROW1
07D8 20A207     662            jb COL1, CHECK_COL_29
07DB 7F01       662            mov R7, #01H
07DD 30A2FD     662            jnb COL1, $ ; wait for key release
07E0 D3         662            setb c
07E1 22         662            ret
07E2            662   CHECK_COL_29:
07E2            662   
07E2 20A407     663            jb COL2, CHECK_COL_30
07E5 7F02       663            mov R7, #02H
07E7 30A4FD     663            jnb COL2, $ ; wait for key release
07EA D3         663            setb c
07EB 22         663            ret
07EC            663   CHECK_COL_30:
07EC 20A607     664            jb COL3, CHECK_COL_31
07EF 7F03       664            mov R7, #03H
07F1 30A6FD     664            jnb COL3, $ ; wait for key release
07F4 D3         664            setb c
07F5 22         664            ret
07F6            664   CHECK_COL_31:
07F6 20B007     665            jb COL4, CHECK_COL_32
07F9 7F0A       665            mov R7, #0AH
07FB 30B0FD     665            jnb COL4, $ ; wait for key release
07FE D3         665            setb c
07FF 22         665            ret
0800            665   CHECK_COL_32:
0800            666   
0800 D292       667            setb ROW1
0802            668   
0802            669            ; Check row 2   
0802            670   
0802 C294       671            clr ROW2
0804 20A207     672            jb COL1, CHECK_COL_33
0807 7F04       672            mov R7, #04H
0809 30A2FD     672            jnb COL1, $ ; wait for key release
080C D3         672            setb c
080D 22         672            ret
080E            672   CHECK_COL_33:
080E 20A407     673            jb COL2, CHECK_COL_34
0811 7F05       673            mov R7, #05H
0813 30A4FD     673            jnb COL2, $ ; wait for key release
0816 D3         673            setb c
0817 22         673            ret
0818            673   CHECK_COL_34:
0818 20A607     674            jb COL3, CHECK_COL_35
081B 7F06       674            mov R7, #06H
081D 30A6FD     674            jnb COL3, $ ; wait for key release
0820 D3         674            setb c
0821 22         674            ret
0822            674   CHECK_COL_35:
0822 20B007     675            jb COL4, CHECK_COL_36
0825 7F0B       675            mov R7, #0BH
0827 30B0FD     675            jnb COL4, $ ; wait for key release
082A D3         675            setb c
082B 22         675            ret
082C            675   CHECK_COL_36:
082C            676   
082C D294       677            setb ROW2
082E            678   
082E            679            ; Check row 3   
082E            680   
082E C296       681            clr ROW3
0830 20A207     682            jb COL1, CHECK_COL_37
0833 7F07       682            mov R7, #07H
0835 30A2FD     682            jnb COL1, $ ; wait for key release
0838 D3         682            setb c
0839 22         682            ret
083A            682   CHECK_COL_37:
083A 20A407     683            jb COL2, CHECK_COL_38
083D 7F08       683            mov R7, #08H
083F 30A4FD     683            jnb COL2, $ ; wait for key release
0842 D3         683            setb c
0843 22         683            ret
0844            683   CHECK_COL_38:
0844 20A607     684            jb COL3, CHECK_COL_39
0847 7F09       684            mov R7, #09H
0849 30A6FD     684            jnb COL3, $ ; wait for key release
084C D3         684            setb c
084D 22         684            ret
084E            684   CHECK_COL_39:
084E 20B007     685            jb COL4, CHECK_COL_40
0851 7F0C       685            mov R7, #0CH
0853 30B0FD     685            jnb COL4, $ ; wait for key release
0856 D3         685            setb c
0857 22         685            ret
0858            685   CHECK_COL_40:
0858            686   
0858 D296       687            setb ROW3
085A            688   
085A            689            ; Check row 4   
085A            690   
085A C2A0       691            clr ROW4
085C 20A207     692            jb COL1, CHECK_COL_41
085F 7F0E       692            mov R7, #0EH
0861 30A2FD     692            jnb COL1, $ ; wait for key release
0864 D3         692            setb c
0865 22         692            ret
0866            692   CHECK_COL_41:
0866 20A407     693            jb COL2, CHECK_COL_42
0869 7F00       693            mov R7, #00H
086B 30A4FD     693            jnb COL2, $ ; wait for key release
086E D3         693            setb c
086F 22         693            ret
0870            693   CHECK_COL_42:
0870 20A607     694            jb COL3, CHECK_COL_43
0873 7F0F       694            mov R7, #0FH
0875 30A6FD     694            jnb COL3, $ ; wait for key release
0878 D3         694            setb c
0879 22         694            ret
087A            694   CHECK_COL_43:
087A 20B007     695            jb COL4, CHECK_COL_44
087D 7F0D       695            mov R7, #0DH
087F 30B0FD     695            jnb COL4, $ ; wait for key release
0882 D3         695            setb c
0883 22         695            ret
0884            695   CHECK_COL_44:
0884            696   
0884 D2A0       697            setb ROW4
0886            698   
0886 C3         699            clr c
0887            700   
0887 22         701            ret
0888            702   
0888            703            
0888            704   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
0888            705   T_7seg:
0888 C0F9A4B0   706       DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
     99
088D 9282F880   707       DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
     90
0892 8883C6A1   708       DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F
     868E
0898            709   
0898            710   
0898            711   ; Displays a BCD number in HEX1-HEX0
0898            712   Display_BCD_7_Seg:
0898 C0E0       713       push acc
089A C0D0       714       push psw
089C            715   
089C 85355B     716            mov x+0, TEMP+0
089F 85365C     717            mov x+1, TEMP+1
08A2 120223     718            lcall hex2bcd
08A5            719   
08A5 900888     720            mov dptr, #T_7seg
08A8 E564       721       mov a, bcd+1
08AA 540F       722       anl a, #0FH
08AC 93         723       movc a, @a+dptr
08AD F593       724       mov HEX2, a
08AF            725   
08AF E563       726            mov a, bcd
08B1 C4         727            swap a
08B2 540F       728            anl a, #0FH
08B4 93         729            movc a, @a+dptr
08B5 F592       730            mov HEX1, a
08B7            731   
08B7 E563       732            mov a, bcd
08B9 540F       733            anl a, #0FH
08BB 93         734            movc a, @a+dptr
08BC F591       735            mov HEX0, a
08BE            736   
08BE D0D0       737       pop psw
08C0 D0E0       738       pop acc
08C2            739   
08C2 22         740            ret
08C3            741   
08C3            742   
08C3            743   Check_Select_Button_Press:
08C3 20B40B     744       jb SELECT_BUTTON, Not_Pressed
08C6 120689     745       lcall Wait50ms
08C9 20B405     746       jb SELECT_BUTTON, Not_Pressed
08CC            747   
08CC D203       748       setb SELECT_BUTTON_FLAG
08CE            749   
08CE 30B4FD     750       jnb SELECT_BUTTON, $
08D1            751   
08D1            752       Not_Pressed:
08D1 22         753           ret
08D2            754   
08D2            755   
08D2            756   Check_Param_Button_Press:
08D2 20B30B     757       jb PARAM_BUTTON, Not_Pressed_2
08D5 120689     758       lcall Wait50ms
08D8 20B305     759       jb PARAM_BUTTON, Not_Pressed_2
08DB            760   
08DB D204       761       setb PARAM_BUTTON_FLAG
08DD            762   
08DD 30B3FD     763       jnb PARAM_BUTTON, $
08E0            764   
08E0            765       Not_Pressed_2:
08E0 22         766           ret
08E1            767   
08E1            768       ;---------------READ KEYPAD-------------------;
08E1            769   
08E1            770       ;A Macro essentially works like CHECK_COL(COL#, Literal value coloumn represents)
08E1            771       ;If the column is pressed, R7 will contain the column number (1-4)
08E1            772       
08E1            773   
08E1            774   ;**************************PWM**************************;
08E1            775   pwm_for_flatstates:
08E1            776   ; ---- LOW_LIM = max(0, T_TGT - T_BAND)
08E1 E544       777           MOV     A, TARGET          
08E3 C3         778           CLR     C                 ;clear carry
08E4 9402       779           SUBB    A, #BAND         ; A = A - BAND
08E6 5002       780           JNC     flat_low_ok       
08E8 7400       781           MOV     A, #00h           
08EA            782   flat_low_ok:
08EA F555       783           MOV     LOW_LIMIT, A        ; Store low limit in RAM
08EC            784   
08EC            785           ;compute high limit
08EC E544       786           MOV     A, TARGET          
08EE 2402       787           ADD     A, #BAND         
08F0 5002       788           JNC     flat_high_ok      
08F2 74FF       789           MOV     A, #0FFh          
08F4            790   flat_high_ok:
08F4 F557       791           MOV     HIGH_LIMIT, A       
08F6            792   
08F6            793           ;turn oven on if curren temp is less than low limit
08F6 E535       794           MOV     A, TEMP          ;make sure this variables is right!!!!!!!
08F8 C3         795           CLR     C               
08F9 9555       796           SUBB    A, LOW_LIMIT       
08FB            797                                    
08FB 400A       798           JC      flat_on       ;temp is less than low limit so turn power on since there is carry
08FD            799   
08FD            800           ;if current temp is greater than high lim turn off
08FD E535       801           MOV     A, TEMP
08FF C3         802           CLR     C                 
0900 9557       803           SUBB    A, HIGH_LIMIT       
0902            804                                    
0902 6002       805           JZ      flat_done         ; If equal to HIGH_LIMit do nothing
0904 5004       806           JNC     flat_off      ; If no borrow and not zero T_CUR > HIGH_LIM so turn off
0906            807   
0906            808   flat_done:
0906 22         809           RET                       ; Inside band do nothing, holds prev values
0907            810   flat_on:
0907 D280       811           SETB p0.0      ;turn power on
0909 22         812           RET
090A            813   
090A            814   flat_off:
090A C280       815           CLR p0.0      ;power off
090C 22         816           RET
090D            817   
090D            818   
090D            819   
090D            820   
090D            821   pwm_for_ramp:
090D E544       822                    MOV     A, TARGET          
090F C3         823           CLR     C                 
0910 9414       824           SUBB    A, #LEAD         
0912            825                                    
0912 5002       826           JNC     ramp_thresh_ok    
0914 7400       827           MOV     A, #00h           
0916            828   ramp_thresh_ok:
0916 F559       829           MOV     THRESHOLD, A         
0918            830   
0918            831           ;if less than threshold turn power on 
0918 E535       832           MOV     A, TEMP          
091A C3         833           CLR     C                 
091B 9559       834           SUBB    A, THRESHOLD         ; A = curren temp - threshold(target-lead)
091D            835                                    
091D 4004       836           JC      ramp_force_on     ; If below threshold force on and return
091F            837   
091F 020926     838           ljmp     ramp_set_off     
0922            839   
0922            840   
0922            841   ramp_done:
0922 22         842           RET                      
0923            843   
0923            844   ramp_force_on:
0923 D280       845           SETB p0.0      ;power on
0925 22         846           RET
0926            847   
0926            848   ramp_set_off:
0926 C280       849           CLR p0.0
0928 22         850           RET 
0929            851           
0929            852   
0929            853   pwm_for_ramp2:
0929 E544       854                    MOV     A, TARGET          
092B C3         855           CLR     C                 
092C 9404       856           SUBB    A, #LEAD2         
092E            857                                    
092E 5002       858           JNC     ramp_thresh_ok2    
0930 7400       859           MOV     A, #00h           
0932            860   ramp_thresh_ok2:
0932 F559       861           MOV     THRESHOLD, A         
0934            862   
0934            863           ;if less than threshold turn power on 
0934 E535       864           MOV     A, TEMP          
0936 C3         865           CLR     C                 
0937 9559       866           SUBB    A, THRESHOLD         ; A = curren temp - threshold(target-lead)
0939            867                                    
0939 4004       868           JC      ramp_force_on2     ; If below threshold force on and return
093B            869   
093B 020942     870           ljmp     ramp_set_off2     
093E            871   
093E            872   
093E            873   ramp_done2:
093E 22         874           RET                      
093F            875   
093F            876   ramp_force_on2:
093F D280       877           SETB p0.0      ;power on
0941 22         878           RET
0942            879   
0942            880   ramp_set_off2:
0942 C280       881           CLR p0.0
0944 22         882           RET 
0945            883   
0945            884   ;==============SPEAKER FUNCTIONS==============;
0945            885   
0945            886   BeepSpeaker:
0945 D28C       887       setb TR0
0947 7B07       888       mov R3, #7
0949            889   WaitLoop:
0949 120689     890       lcall Wait50ms
094C DBFB       891       djnz R3, WaitLoop 
094E            892   UnbeepSpeaker:
094E C28C       893       clr TR0
0950 22         894       ret
0951            895   
0951            896   ;=============================================;
0951            897   
0951            898   FSM2_Temp_Time_display:
0951            899       ;print time
0951 C0E0       900            push acc
0953 7401       900            mov a, #1
0955 14         900            dec a
0956 120206     900            lcall ?Set_Cursor_2 ; Select column and row
0959 D0E0       900            pop acc
095B C083       901            push dph
095D C082       901            push dpl
095F C0E0       901            push acc
0961 900160     901            mov dptr, #TimeLabel
0964 1201FB     901            lcall ?Send_Constant_String
0967 D0E0       901            pop acc
0969 D082       901            pop dpl
096B D083       901            pop dph
096D            902   
096D 853A5B     903       mov x+0, TIME+0
0970 853B5C     904       mov x+1, TIME+1
0973 755D00     905       mov x+2, #0
0976 755E00     906       mov x+3, #0
0979 120223     907       lcall hex2bcd
097C            908   
097C C0E0       909            push acc
097E 7406       909            mov a, #6
0980 14         909            dec a
0981 120206     909            lcall ?Set_Cursor_2 ; Select column and row
0984 D0E0       909            pop acc
0986 C000       910            push ar0
0988 A864       910            mov r0, bcd+1
098A 12020D     910            lcall ?Display_BCD
098D D000       910            pop ar0
098F C000       911            push ar0
0991 A863       911            mov r0, bcd+0
0993 12020D     911            lcall ?Display_BCD
0996 D000       911            pop ar0
0998            912       ;print temp
0998 C0E0       913            push acc
099A 740A       913            mov a, #10
099C 14         913            dec a
099D 120206     913            lcall ?Set_Cursor_2 ; Select column and row
09A0 D0E0       913            pop acc
09A2 C083       914            push dph
09A4 C082       914            push dpl
09A6 C0E0       914            push acc
09A8 900166     914            mov dptr, #TempLabel
09AB 1201FB     914            lcall ?Send_Constant_String
09AE D0E0       914            pop acc
09B0 D082       914            pop dpl
09B2 D083       914            pop dph
09B4            915   
09B4 85355B     916       mov x+0, TEMP+0
09B7 85365C     917       mov x+1, TEMP+1
09BA 755D00     918       mov x+2, #0
09BD 755E00     919       mov x+3, #0
09C0 120223     920       lcall hex2bcd
09C3            921   
09C3 C0E0       922            push acc
09C5 740D       922            mov a, #16-3
09C7 14         922            dec a
09C8 120206     922            lcall ?Set_Cursor_2 ; Select column and row
09CB D0E0       922            pop acc      
09CD C000       923            push ar0
09CF A864       923            mov r0, bcd+1
09D1 12020D     923            lcall ?Display_BCD
09D4 D000       923            pop ar0
09D6 C000       924            push ar0
09D8 A863       924            mov r0, bcd+0
09DA 12020D     924            lcall ?Display_BCD
09DD D000       924            pop ar0
09DF 22         925       ret
09E0            926   
09E0            927   ;--- MAIN PROGRAM START ---
09E0            928   
09E0            929   ; **************************************** Initializations ***********************************************
09E0            930   
09E0            931   MAIN:
09E0 75817F     932       mov SP, #0x7F         ; Initialize Stack Pointer (Good practice)
09E3 120676     933       lcall INITIALIZE      ; intialize pins and adc, for now
09E6            934   
09E6 120579     935       lcall Timer0_Init
09E9 120595     936       lcall Timer2_Init
09EC D2AF       937       setB EA ; Enable global interrupts
09EE 1201C8     938       lcall ELCD_4BIT ; Intialize LCD
09F1 120515     939       lcall InitSerialPort
09F4            940       
09F4 C202       941       clr seconds_flag
09F6 C200       942       clr START_FLAG
09F8 C205       943       clr KEYPAD_FLAG
09FA C280       944       clr p0.0 ; Make sure oven is off to start
09FC C28C       945       clr TR0 ; Start speaker off
09FE E4         946       clr a
09FF            947   
09FF            948   
09FF 753000     949       mov STATE_VAR_1, #0x0000
0A02 753100     950       mov STATE_VAR_2, #0x0000
0A05 753A00     951       mov TIME, #0
0A08 753500     952       mov TEMP, #0000
0A0B 753C00     953       mov POWER, #0
0A0E 753E3C     954       mov DEGREES60, #60
0A11 754096     955       mov DEGREES150, #150
0A14 7542DC     956       mov DEGREES220, #220
0A17 754400     957       mov TARGET,       #0
0A1A            958   
0A1A 756300     959       mov bcd, #0x0000
0A1D 755B00     960       mov x+0, #0x0000
0A20 755C00     961       mov x+1, #0x0000
0A23 755D00     962       mov x+2, #0x0000
0A26 755E00     963       mov x+3, #0x0000
0A29            964   
0A29 754896     965       mov soak_temp_set+0, #150
0A2C F549       966       mov soak_temp_set+1, a
0A2E            967   
0A2E 754A3C     968       mov soak_time_set+0, #60
0A31 F54B       969       mov soak_time_set+1, a
0A33            970   
0A33 754CDC     971       mov reflow_temp_set+0, #220
0A36 F54D       972       mov reflow_temp_set+1, a
0A38            973   
0A38 754E1E     974       mov reflow_time_set+0, #30
0A3B F54F       975       mov reflow_time_set+1, a
0A3D            976   
0A3D            977   
0A3D            978   MAIN_LOOP:
0A3D            979   
0A3D            980   PARAM_FSM:
0A3D            981   
0A3D            982   ; **************************** FSM for selecting parameters *************************
0A3D            983   
0A3D            984   ; 4 main states ->  A: select soak temp
0A3D            985   ;                   B: select soak time
0A3D            986   ;                   C: select reflow temp
0A3D            987   ;                   D: select reflow time
0A3D            988   ; move to other FSM when start button turns on start flag
0A3D            989   
0A3D            990   StateAInit:
0A3D C0E0       991            push acc
0A3F 7401       991            mov a, #1
0A41 14         991            dec a
0A42 120208     991            lcall ?Set_Cursor_1 ; Select column and row
0A45 D0E0       991            pop acc
0A47 C083       992            push dph
0A49 C082       992            push dpl
0A4B C0E0       992            push acc
0A4D 90003F     992            mov dptr, #param_message
0A50 1201FB     992            lcall ?Send_Constant_String
0A53 D0E0       992            pop acc
0A55 D082       992            pop dpl
0A57 D083       992            pop dph
0A59 C0E0       993            push acc
0A5B 7401       993            mov a, #1
0A5D 14         993            dec a
0A5E 120206     993            lcall ?Set_Cursor_2 ; Select column and row
0A61 D0E0       993            pop acc
0A63 C083       994            push dph
0A65 C082       994            push dpl
0A67 C0E0       994            push acc
0A69 900050     994            mov dptr, #soak_temp_message
0A6C 1201FB     994            lcall ?Send_Constant_String
0A6F D0E0       994            pop acc
0A71 D082       994            pop dpl
0A73 D083       994            pop dph
0A75            994   
0A75            995   
0A75 C205       996       clr KEYPAD_FLAG
0A77 756B00     997       mov keypad_digit_count, #0
0A7A            998   
0A7A            999   StateA:
0A7A 30F93E    1000       jnb RESET_BUTTON, StateA_ResetToMain
0A7D E531      1001       mov a, STATE_VAR_2
0A7F B4003C    1002       cjne a, #0, StateA_B
0A82           1003   
0A82 1208C3    1004       lcall Check_Select_Button_Press
0A85 200339    1005       jb SELECT_BUTTON_FLAG, StateAtoDone
0A88           1006   
0A88 85485B    1007       mov x+0, soak_temp_set+0
0A8B 85495C    1008       mov x+1, soak_temp_set+1
0A8E 755D00    1009       mov x+2, #0
0A91 755E00    1010       mov x+3, #0
0A94 120223    1011       lcall hex2bcd
0A97           1012   
0A97 C0E0      1013            push acc
0A99 740C      1013            mov a, #12
0A9B 14        1013            dec a
0A9C 120206    1013            lcall ?Set_Cursor_2 ; Select column and row
0A9F D0E0      1013            pop acc
0AA1 C000      1014            push ar0
0AA3 A864      1014            mov r0, bcd+1
0AA5 12020D    1014            lcall ?Display_BCD
0AA8 D000      1014            pop ar0
0AAA C000      1015            push ar0
0AAC A863      1015            mov r0, bcd+0
0AAE 12020D    1015            lcall ?Display_BCD
0AB1 D000      1015            pop ar0
0AB3           1016   
0AB3 1208D2    1017       lcall Check_Param_Button_Press
0AB6 20045B    1018       jb PARAM_BUTTON_FLAG, Inc_Soak_Temp
0AB9 8009      1019       sjmp StateA_Keypad
0ABB           1020   
0ABB           1021   StateA_ResetToMain:
0ABB 0209E0    1022   ljmp MAIN   
0ABE           1023   
0ABE           1024   StateA_B:
0ABE 020B48    1025   ljmp StateBInit
0AC1           1026   
0AC1           1027   StateAtoDone:
0AC1 020B38    1028   ljmp StateADone
0AC4           1029   
0AC4           1030   StateA_Keypad:
0AC4 120791    1031       lcall Keypad
0AC7 50B1      1032       jnc StateA
0AC9           1033   
0AC9 20050C    1034       jb KEYPAD_FLAG, StateA_Keypad_Continue
0ACC D205      1035       setb KEYPAD_FLAG
0ACE           1036   
0ACE 7400      1037       mov a, #0
0AD0 F563      1038       mov bcd+0, a
0AD2 F564      1039       mov bcd+1, a
0AD4 F565      1040       mov bcd+2, a
0AD6 F566      1041       mov bcd+3, a
0AD8           1042   
0AD8           1043   StateA_Keypad_Continue:
0AD8 12070C    1044       lcall Shift_Digits_Left
0ADB 509D      1045       jnc StateA
0ADD           1046   
0ADD 120270    1047       lcall bcd2hex
0AE0           1048   
0AE0 855B48    1049       mov soak_temp_set+0, x+0
0AE3 855C49    1050       mov soak_temp_set+1, x+1
0AE6           1051   
0AE6 85485B    1052       mov x+0, soak_temp_set+0
0AE9 85495C    1053       mov x+1, soak_temp_set+1
0AEC 755D00    1054       mov x+2, #0
0AEF 755E00    1055       mov x+3, #0
0AF2 120223    1056       lcall hex2bcd
0AF5           1057   
0AF5 C0E0      1058            push acc
0AF7 740C      1058            mov a, #12
0AF9 14        1058            dec a
0AFA 120206    1058            lcall ?Set_Cursor_2 ; Select column and row
0AFD D0E0      1058            pop acc
0AFF C000      1059            push ar0
0B01 A864      1059            mov r0, bcd+1
0B03 12020D    1059            lcall ?Display_BCD
0B06 D000      1059            pop ar0
0B08 C000      1060            push ar0
0B0A A863      1060            mov r0, bcd+0
0B0C 12020D    1060            lcall ?Display_BCD
0B0F D000      1060            pop ar0
0B11           1061   
0B11 020A7A    1062       ljmp StateA
0B14           1063   
0B14           1064   
0B14           1065       Inc_Soak_Temp:
0B14 C204      1066           clr PARAM_BUTTON_FLAG
0B16           1067   
0B16 E548      1068           mov a, soak_temp_set
0B18           1069   
0B18 20E80B    1070           jb UPDOWN, Dec_Soak_Temp
0B1B 20E904    1071           jb TENS, Inc_Soak_Temp_Tens
0B1E           1072   
0B1E 2401      1073           add a, #1
0B20 8011      1074           sjmp Soak_Temp_Tens_Done
0B22           1075   
0B22           1076       Inc_Soak_Temp_Tens:
0B22 240A      1077           add a, #10
0B24 800D      1078           sjmp Soak_Temp_Tens_Done
0B26           1079   
0B26           1080       Dec_Soak_Temp:
0B26 20E905    1081           jb TENS, Dec_Soak_Temp_Tens
0B29           1082   
0B29 C3        1083           clr c
0B2A 9401      1084           subb a, #1
0B2C 8005      1085           sjmp Soak_Temp_Tens_Done
0B2E           1086   
0B2E           1087       Dec_Soak_Temp_Tens:
0B2E C3        1088           clr c  
0B2F 940A      1089           subb a, #10
0B31 8000      1090           sjmp Soak_Temp_Tens_Done
0B33           1091   
0B33           1092       Soak_Temp_Tens_Done:
0B33 F548      1093           mov soak_temp_set, a
0B35 020A7A    1094           ljmp StateA
0B38           1095   
0B38           1096   StateADone:
0B38 120945    1097       lcall BeepSpeaker
0B3B 0531      1098       inc STATE_VAR_2
0B3D C203      1099       clr SELECT_BUTTON_FLAG
0B3F C205      1100       clr KEYPAD_FLAG
0B41 7400      1101       mov a, #0
0B43 F56B      1102       mov keypad_digit_count, a
0B45 020A7A    1103       ljmp StateA
0B48           1104   
0B48           1105   
0B48           1106   StateBInit:
0B48 C0E0      1107            push acc
0B4A 7401      1107            mov a, #1
0B4C 14        1107            dec a
0B4D 120206    1107            lcall ?Set_Cursor_2 ; Select column and row
0B50 D0E0      1107            pop acc
0B52 C083      1108            push dph
0B54 C082      1108            push dpl
0B56 C0E0      1108            push acc
0B58 900061    1108            mov dptr, #soak_time_message
0B5B 1201FB    1108            lcall ?Send_Constant_String
0B5E D0E0      1108            pop acc
0B60 D082      1108            pop dpl
0B62 D083      1108            pop dph
0B64           1109   
0B64           1110   StateB:
0B64 30F935    1111       jnb RESET_BUTTON, StateB_ResetToMain
0B67 E531      1112       mov a, STATE_VAR_2
0B69 B40162    1113       cjne a, #1, StateCInit
0B6C           1114   
0B6C 1208C3    1115       lcall Check_Select_Button_Press
0B6F 200353    1116       jb SELECT_BUTTON_FLAG, StateBDone
0B72           1117   
0B72 854A5B    1118       mov x+0, soak_time_set+0
0B75 755C00    1119       mov x+1, #0
0B78 755D00    1120       mov x+2, #0
0B7B 755E00    1121       mov x+3, #0
0B7E 120223    1122       lcall hex2bcd
0B81           1123   
0B81 C0E0      1124            push acc
0B83 740C      1124            mov a, #12
0B85 14        1124            dec a
0B86 120206    1124            lcall ?Set_Cursor_2 ; Select column and row
0B89 D0E0      1124            pop acc
0B8B C000      1125            push ar0
0B8D A863      1125            mov r0, bcd+0
0B8F 12020D    1125            lcall ?Display_BCD
0B92 D000      1125            pop ar0
0B94           1126   
0B94 1208D2    1127       lcall Check_Param_Button_Press
0B97 200408    1128       jb PARAM_BUTTON_FLAG, Inc_Soak_Time
0B9A           1129   
0B9A           1130   StateB_Keypad:
0B9A           1131       ;lcall Keypad
0B9A           1132       ;jnc StateB
0B9A           1133   
0B9A           1134       ;lcall Shift_Digits_Left
0B9A           1135   
0B9A           1136       ;mov soak_time_set+0, bcd+0
0B9A           1137       ;mov soak_time_set+1, bcd+1
0B9A           1138   
0B9A 80C8      1139       sjmp StateB
0B9C           1140   
0B9C           1141   StateB_ResetToMain:
0B9C 0209E0    1142   ljmp MAIN
0B9F           1143   
0B9F           1144   StateB_C:
0B9F 020BCE    1145   ljmp StateCInit
0BA2           1146   
0BA2           1147   
0BA2           1148       Inc_Soak_Time:
0BA2 C204      1149           clr PARAM_BUTTON_FLAG
0BA4           1150   
0BA4 E54A      1151           mov a, soak_time_set
0BA6           1152   
0BA6 20E80B    1153           jb UPDOWN, Dec_Soak_Time
0BA9 20E904    1154           jb TENS, Inc_Soak_Time_Tens
0BAC           1155   
0BAC 2401      1156           add a, #1
0BAE 8011      1157           sjmp Soak_Time_Tens_Done
0BB0           1158   
0BB0           1159       Inc_Soak_Time_Tens:
0BB0 240A      1160           add a, #10
0BB2 800D      1161           sjmp Soak_Time_Tens_Done
0BB4           1162   
0BB4           1163       Dec_Soak_Time:
0BB4 20E905    1164           jb TENS, Dec_Soak_Time_Tens
0BB7 C3        1165           clr c
0BB8           1166   
0BB8 9401      1167           subb a, #1
0BBA 8005      1168           sjmp Soak_Time_Tens_Done
0BBC           1169   
0BBC           1170       Dec_Soak_Time_Tens:
0BBC C3        1171           clr c
0BBD           1172   
0BBD 940A      1173           subb a, #10
0BBF 8000      1174           sjmp Soak_Time_Tens_Done
0BC1           1175   
0BC1           1176       Soak_Time_Tens_Done:
0BC1 F54A      1177           mov soak_time_set, a
0BC3 809F      1178           sjmp StateB
0BC5           1179   
0BC5           1180   StateBDone:
0BC5 120945    1181       lcall BeepSpeaker
0BC8 0531      1182       inc STATE_VAR_2
0BCA C203      1183       clr SELECT_BUTTON_FLAG
0BCC 8096      1184       sjmp StateB
0BCE           1185   
0BCE           1186   
0BCE           1187   StateCInit:
0BCE C0E0      1188            push acc
0BD0 7401      1188            mov a, #1
0BD2 14        1188            dec a
0BD3 120206    1188            lcall ?Set_Cursor_2 ; Select column and row
0BD6 D0E0      1188            pop acc
0BD8 C083      1189            push dph
0BDA C082      1189            push dpl
0BDC C0E0      1189            push acc
0BDE 900072    1189            mov dptr, #reflow_temp_message
0BE1 1201FB    1189            lcall ?Send_Constant_String
0BE4 D0E0      1189            pop acc
0BE6 D082      1189            pop dpl
0BE8 D083      1189            pop dph
0BEA           1190   StateC:
0BEA 30F93E    1191       jnb RESET_BUTTON, StateC_ResetToMain
0BED E531      1192       mov a, STATE_VAR_2
0BEF B4026B    1193       cjne a, #2, StateDInit
0BF2           1194   
0BF2 1208C3    1195       lcall Check_Select_Button_Press
0BF5 20035C    1196       jb SELECT_BUTTON_FLAG, StateCDone
0BF8           1197   
0BF8 854C5B    1198       mov x+0, reflow_temp_set+0
0BFB 854D5C    1199       mov x+1, reflow_temp_set+1
0BFE 755D00    1200       mov x+2, #0x0000
0C01 755E00    1201       mov x+3, #0x0000
0C04           1202   
0C04 120223    1203       lcall hex2bcd
0C07           1204   
0C07 C0E0      1205            push acc
0C09 740C      1205            mov a, #12
0C0B 14        1205            dec a
0C0C 120206    1205            lcall ?Set_Cursor_2 ; Select column and row
0C0F D0E0      1205            pop acc
0C11 C000      1206            push ar0
0C13 A864      1206            mov r0, bcd+1
0C15 12020D    1206            lcall ?Display_BCD
0C18 D000      1206            pop ar0
0C1A C000      1207            push ar0
0C1C A863      1207            mov r0, bcd+0
0C1E 12020D    1207            lcall ?Display_BCD
0C21 D000      1207            pop ar0
0C23           1208   
0C23 1208D2    1209       lcall Check_Param_Button_Press
0C26 200408    1210       jb PARAM_BUTTON_FLAG, Inc_Reflow_Temp
0C29           1211   
0C29           1212   StateC_Keypad:
0C29           1213       ;lcall Keypad
0C29           1214       ;jnc StateC
0C29           1215   
0C29           1216       ;lcall Shift_Digits_Left
0C29           1217   
0C29           1218       ;mov reflow_temp_set+0, bcd+0
0C29           1219       ;mov reflow_temp_set+1, bcd+1
0C29           1220   
0C29 80BF      1221       sjmp StateC
0C2B           1222   
0C2B           1223   StateC_ResetToMain:
0C2B 0209E0    1224   ljmp MAIN
0C2E           1225   
0C2E           1226   StateC_D:
0C2E 020C5D    1227   ljmp StateDInit
0C31           1228   
0C31           1229   
0C31           1230       Inc_Reflow_Temp:
0C31 C204      1231           clr PARAM_BUTTON_FLAG
0C33 E54C      1232           mov a, reflow_temp_set
0C35           1233   
0C35 20E80B    1234           jb UPDOWN, Dec_Reflow_Temp
0C38 20E904    1235           jb TENS, Inc_Reflow_Temp_Tens
0C3B           1236   
0C3B 2401      1237           add a, #1
0C3D 8011      1238           sjmp Reflow_Temp_Tens_Done
0C3F           1239   
0C3F           1240       Inc_Reflow_Temp_Tens:
0C3F 240A      1241           add a, #10
0C41 800D      1242           sjmp Reflow_Temp_Tens_Done
0C43           1243   
0C43           1244       Dec_Reflow_Temp:
0C43 20E905    1245           jb TENS, Dec_Reflow_Temp_Tens
0C46           1246   
0C46 C3        1247           clr c
0C47 9401      1248           subb a, #1
0C49 8005      1249           sjmp Reflow_Temp_Tens_Done
0C4B           1250   
0C4B           1251       Dec_Reflow_Temp_Tens:
0C4B C3        1252           clr c
0C4C 940A      1253           subb a, #10
0C4E 8000      1254           sjmp Reflow_Temp_Tens_Done
0C50           1255   
0C50           1256       Reflow_Temp_Tens_Done:
0C50 F54C      1257           mov reflow_temp_set, a
0C52 8096      1258           sjmp StateC
0C54           1259   
0C54           1260   StateCDone:
0C54 120945    1261       lcall BeepSpeaker
0C57 0531      1262       inc STATE_VAR_2
0C59 C203      1263       clr SELECT_BUTTON_FLAG
0C5B 808D      1264       sjmp StateC
0C5D           1265   
0C5D           1266   
0C5D           1267   StateDInit:
0C5D C0E0      1268            push acc
0C5F 7401      1268            mov a, #1
0C61 14        1268            dec a
0C62 120206    1268            lcall ?Set_Cursor_2 ; Select column and row
0C65 D0E0      1268            pop acc
0C67 C083      1269            push dph
0C69 C082      1269            push dpl
0C6B C0E0      1269            push acc
0C6D 900083    1269            mov dptr, #reflow_time_message
0C70 1201FB    1269            lcall ?Send_Constant_String
0C73 D0E0      1269            pop acc
0C75 D082      1269            pop dpl
0C77 D083      1269            pop dph
0C79           1270   
0C79           1271   StateD:
0C79 30F935    1272       jnb RESET_BUTTON, StateD_ResetToMain
0C7C E531      1273       mov a, STATE_VAR_2
0C7E B40333    1274       cjne a, #3, StateD_R
0C81           1275   
0C81 1208C3    1276       lcall Check_Select_Button_Press
0C84 200353    1277       jb SELECT_BUTTON_FLAG, StateDDone
0C87           1278   
0C87 854E5B    1279       mov x+0, reflow_time_set+0
0C8A 755C00    1280       mov x+1, #0
0C8D 755D00    1281       mov x+2, #0
0C90 755E00    1282       mov x+3, #0
0C93 120223    1283       lcall hex2bcd
0C96           1284   
0C96 C0E0      1285            push acc
0C98 740C      1285            mov a, #12
0C9A 14        1285            dec a
0C9B 120206    1285            lcall ?Set_Cursor_2 ; Select column and row
0C9E D0E0      1285            pop acc
0CA0 C000      1286            push ar0
0CA2 A863      1286            mov r0, bcd+0
0CA4 12020D    1286            lcall ?Display_BCD
0CA7 D000      1286            pop ar0
0CA9           1287   
0CA9 1208D2    1288       lcall Check_Param_Button_Press
0CAC 200408    1289       jb PARAM_BUTTON_FLAG, Inc_Reflow_Time
0CAF           1290   
0CAF           1291   StateD_Keypad:
0CAF           1292       ;lcall Keypad 
0CAF           1293       ;jnc StateD
0CAF           1294   
0CAF           1295       ;lcall Shift_Digits_Left
0CAF           1296   
0CAF           1297       ;mov reflow_time_set+0, bcd+0
0CAF           1298       ;mov reflow_time_set+1, bcd+1
0CAF           1299   
0CAF 80C8      1300       sjmp StateD
0CB1           1301   
0CB1           1302   StateD_ResetToMain:
0CB1 0209E0    1303   ljmp MAIN
0CB4           1304   
0CB4           1305   StateD_R:
0CB4 020CE3    1306   ljmp ReadyStateInit
0CB7           1307   
0CB7           1308   
0CB7           1309       Inc_Reflow_Time:        
0CB7 C204      1310           clr PARAM_BUTTON_FLAG
0CB9 E54E      1311           mov a, reflow_time_set
0CBB           1312   
0CBB 20E80B    1313           jb UPDOWN, Dec_Reflow_Time
0CBE 20E904    1314           jb TENS, Inc_Reflow_Time_Tens
0CC1           1315   
0CC1 2401      1316           add a, #1
0CC3 8011      1317           sjmp Reflow_Time_Tens_Done
0CC5           1318   
0CC5           1319       Inc_Reflow_Time_Tens:
0CC5 240A      1320           add a, #10
0CC7 800D      1321           sjmp Reflow_Time_Tens_Done
0CC9           1322   
0CC9           1323       Dec_Reflow_Time:
0CC9 20E905    1324           jb TENS, Dec_Reflow_Time_Tens
0CCC C3        1325           clr c
0CCD           1326   
0CCD 9401      1327           subb a, #1
0CCF 8005      1328           sjmp Reflow_Time_Tens_Done
0CD1           1329   
0CD1           1330       Dec_Reflow_Time_Tens:
0CD1 C3        1331           clr c
0CD2           1332   
0CD2 940A      1333           subb a, #10
0CD4 8000      1334           sjmp Reflow_Time_Tens_Done
0CD6           1335   
0CD6           1336       Reflow_Time_Tens_Done:
0CD6 F54E      1337           mov reflow_time_set, a
0CD8 809F      1338           sjmp StateD
0CDA           1339   
0CDA           1340   StateDDone:
0CDA 120945    1341       lcall BeepSpeaker
0CDD 0531      1342       inc STATE_VAR_2
0CDF C203      1343       clr SELECT_BUTTON_FLAG
0CE1 8096      1344       sjmp StateD
0CE3           1345   
0CE3           1346   
0CE3           1347   ReadyStateInit:
0CE3 C0E0      1348            push acc
0CE5 7401      1348            mov a, #1
0CE7 14        1348            dec a
0CE8 120208    1348            lcall ?Set_Cursor_1 ; Select column and row
0CEB D0E0      1348            pop acc
0CED C083      1349            push dph
0CEF C082      1349            push dpl
0CF1 C0E0      1349            push acc
0CF3 900094    1349            mov dptr, #ready_message
0CF6 1201FB    1349            lcall ?Send_Constant_String
0CF9 D0E0      1349            pop acc
0CFB D082      1349            pop dpl
0CFD D083      1349            pop dph
0CFF C0E0      1350            push acc
0D01 7401      1350            mov a, #1
0D03 14        1350            dec a
0D04 120206    1350            lcall ?Set_Cursor_2 ; Select column and row
0D07 D0E0      1350            pop acc
0D09 C083      1351            push dph
0D0B C082      1351            push dpl
0D0D C0E0      1351            push acc
0D0F 90002E    1351            mov dptr, #blank_row
0D12 1201FB    1351            lcall ?Send_Constant_String
0D15 D0E0      1351            pop acc
0D17 D082      1351            pop dpl
0D19 D083      1351            pop dph
0D1B           1352   
0D1B           1353   ReadyState:
0D1B           1354       ;jnb seconds_flag, skipSerial_0 *** not too sure what this does
0D1B           1355   
0D1B           1356   skipSerial_0:
0D1B 20B5FD    1357       jb START_BUTTON, ReadyState
0D1E 120689    1358       lcall wait50ms
0D21 20B5F7    1359       jb START_BUTTON, ReadyState
0D24           1360   
0D24 C0E0      1361            push acc
0D26 7401      1361            mov a, #1
0D28 14        1361            dec a
0D29 120208    1361            lcall ?Set_Cursor_1 ; Select column and row
0D2C D0E0      1361            pop acc
0D2E C083      1362            push dph
0D30 C082      1362            push dpl
0D32 C0E0      1362            push acc
0D34 9000A5    1362            mov dptr, #state0_message
0D37 1201FB    1362            lcall ?Send_Constant_String
0D3A D0E0      1362            pop acc
0D3C D082      1362            pop dpl
0D3E D083      1362            pop dph
0D40           1363   
0D40 D200      1364       setb START_FLAG
0D42           1365       
0D42 8000      1366       sjmp State0
0D44           1367   
0D44           1368   ;==================Reflow Profile FSM==================;
0D44           1369   ;Checklist:
0D44           1370   ; 1. Implement TEMP and TIME variables - DONE
0D44           1371   ; 2. Implement FSM outputs - DONE
0D44           1372   ; 3. Implement reset logic - DONE
0D44           1373   ; 4. Implement abort condition - DONE
0D44           1374   ; 5. Implement LCD Feedback for Each State - Tentatively Done (Still not tested)
0D44           1375   ; 6. Speaker beeps for state transitions - DONE
0D44           1376   ;*Abort condition needs to be in state 1* - FIXED
0D44           1377   ; 7. Rewrite State Transitions with SUBB - DONE
0D44           1378   State0:
0D44 30B70C    1379       jnb STOP_BUTTON, State0_StopReflow
0D47 C280      1380       CLR p0.0 ;oven off
0D49 E530      1381       mov a, STATE_VAR_1
0D4B B40015    1382       cjne a, #0, State1
0D4E 200005    1383       jb START_FLAG, State0Done
0D51 80F1      1384       sjmp State0
0D53           1385   
0D53           1386   State0_StopReflow:
0D53 020F4A    1387   ljmp StopReflow
0D56           1388   
0D56           1389   State0Done:
0D56 120945    1390       lcall BeepSpeaker
0D59 0530      1391       inc STATE_VAR_1
0D5B 753C64    1392       mov POWER, #100
0D5E 753A00    1393       mov TIME, #0
0D61 80E1      1394       sjmp State0
0D63           1395   State1:
0D63 30F937    1396       jnb RESET_BUTTON, State1_ResetToMain
0D66 30B737    1397       jnb STOP_BUTTON, State1_StopReflow
0D69 E530      1398       mov a, STATE_VAR_1
0D6B B40148    1399       cjne a, #1, State2
0D6E C0E0      1400            push acc
0D70 7401      1400            mov a, #1
0D72 14        1400            dec a
0D73 120208    1400            lcall ?Set_Cursor_1 ; Select column and row
0D76 D0E0      1400            pop acc
0D78 C083      1401            push dph
0D7A C082      1401            push dpl
0D7C C0E0      1401            push acc
0D7E 9000B6    1401            mov dptr, #state1_message
0D81 1201FB    1401            lcall ?Send_Constant_String
0D84 D0E0      1401            pop acc
0D86 D082      1401            pop dpl
0D88 D083      1401            pop dph
0D8A 120951    1402       lcall FSM2_Temp_Time_display
0D8D 120E01    1403       lcall CheckAbortCondition ;Must abort if 50 degrees isn't reached in first 60 seconds
0D90           1404   
0D90 854844    1405       mov TARGET, SOAK_TEMP_set
0D93 E535      1406       mov a, TEMP
0D95 C3        1407       clr c
0D96 9544      1408       subb a, TARGET
0D98 4009      1409       jc CheckCarryState1 ; C = 1, Keep heating
0D9A 020DA9    1410       ljmp GreaterThanState1 ; C = 0, Transition States
0D9D           1411   
0D9D           1412   State1_ResetToMain:
0D9D 020F41    1413   ljmp ResetToMain
0DA0           1414   
0DA0           1415   State1_StopReflow:
0DA0 020F4A    1416   ljmp StopReflow
0DA3           1417   
0DA3           1418   CheckCarryState1:
0DA3 4002      1419       jc LessThanState1
0DA5 8002      1420       sjmp GreaterThanState1
0DA7           1421   LessThanState1:
0DA7 80BA      1422       sjmp State1
0DA9           1423   GreaterThanState1:
0DA9 120945    1424       lcall BeepSpeaker
0DAC 0530      1425       inc STATE_VAR_1
0DAE 753C14    1426       mov POWER, #20
0DB1 753A00    1427       mov TIME, #0
0DB4 80AD      1428       sjmp State1
0DB6           1429   State2:
0DB6 30F937    1430       jnb RESET_BUTTON, State2_ResetToMain
0DB9 30B737    1431       jnb STOP_BUTTON, State2_StopReflow
0DBC E530      1432       mov a, STATE_VAR_1
0DBE B4022C    1433       cjne a, #2, State2_State3
0DC1 C0E0      1434            push acc
0DC3 7401      1434            mov a, #1
0DC5 14        1434            dec a
0DC6 120208    1434            lcall ?Set_Cursor_1 ; Select column and row
0DC9 D0E0      1434            pop acc
0DCB C083      1435            push dph
0DCD C082      1435            push dpl
0DCF C0E0      1435            push acc
0DD1 9000C7    1435            mov dptr, #state2_message
0DD4 1201FB    1435            lcall ?Send_Constant_String
0DD7 D0E0      1435            pop acc
0DD9 D082      1435            pop dpl
0DDB D083      1435            pop dph
0DDD 120951    1436       lcall FSM2_Temp_Time_display
0DE0 854A46    1437       mov TARGET_TIME, SOAK_TIME_set
0DE3 E53A      1438       mov a, TIME
0DE5 C3        1439       clr c
0DE6 9546      1440       subb a, TARGET_TIME
0DE8 4020      1441       jc CheckCarryState2 ; C = 1, TIME < TARGET_TIME
0DEA 020E10    1442       ljmp GreaterThanState2 ; C = 0, TIME > TARGET_TIME -> transition states
0DED           1443   
0DED           1444   State2_State3:
0DED 020E1B    1445       ljmp State3
0DF0           1446   
0DF0           1447   State2_ResetToMain:
0DF0 020F41    1448   ljmp ResetToMain
0DF3           1449   
0DF3           1450   State2_StopReflow:
0DF3 020F4A    1451   ljmp StopReflow
0DF6           1452   
0DF6           1453   State1_CheckOven:
0DF6 E53A      1454   mov a, TIME
0DF8 B43C00    1455   cjne a, #60, State1TimeCheckCarry
0DFB           1456   
0DFB           1457   State1TimeCheckCarry:
0DFB 4003      1458   jc TrampolineState1 ; 60 Seconds haven't passed
0DFD 020F89    1459   ljmp STOPOVEN
0E00           1460   
0E00           1461   TrampolineState1:
0E00 22        1462   ret
0E01           1463   
0E01           1464   CheckAbortCondition:
0E01 E535      1465       mov a, TEMP
0E03 B43201    1466       cjne a, #50, CheckAbortCarry
0E06 22        1467       ret
0E07           1468   CheckAbortCarry:
0E07 40ED      1469       jc State1_CheckOven          
0E09 22        1470       ret
0E0A           1471   CheckCarryState2:
0E0A 4002      1472       jc LessThanState2
0E0C 8002      1473       sjmp GreaterThanState2
0E0E           1474   LessThanState2:
0E0E 80A6      1475       sjmp State2
0E10           1476   GreaterThanState2:
0E10 120945    1477       lcall BeepSpeaker
0E13 0530      1478       inc STATE_VAR_1
0E15 753C64    1479       mov POWER, #100
0E18 020DB6    1480       ljmp State2
0E1B           1481   State3:
0E1B 30F934    1482       jnb RESET_BUTTON, State3_ResetToMain
0E1E 30B734    1483       jnb STOP_BUTTON, State3_StopReflow
0E21 E530      1484       mov a, STATE_VAR_1
0E23 B40345    1485       cjne a, #3, State4
0E26 C0E0      1486            push acc
0E28 7401      1486            mov a, #1
0E2A 14        1486            dec a
0E2B 120208    1486            lcall ?Set_Cursor_1 ; Select column and row
0E2E D0E0      1486            pop acc
0E30 C083      1487            push dph
0E32 C082      1487            push dpl
0E34 C0E0      1487            push acc
0E36 9000D8    1487            mov dptr, #state3_message
0E39 1201FB    1487            lcall ?Send_Constant_String
0E3C D0E0      1487            pop acc
0E3E D082      1487            pop dpl
0E40 D083      1487            pop dph
0E42 120951    1488       lcall FSM2_Temp_Time_display
0E45 854C44    1489       mov TARGET, reflow_temp_set
0E48 E535      1490       mov a, TEMP
0E4A C3        1491       clr c
0E4B 9544      1492       subb a, TARGET
0E4D 4009      1493       jc CheckCarryState3 ; C = 1, TEMP < TARGET -> Keep Heating
0E4F 020E5E    1494       ljmp GreaterThanState3 ; C = 0, TEMP > TARGET -> Transition States    
0E52           1495   
0E52           1496   State3_ResetToMain:
0E52 020F41    1497   ljmp ResetToMain
0E55           1498   
0E55           1499   State3_StopReflow:
0E55 020F4A    1500   ljmp StopReflow
0E58           1501   
0E58           1502   CheckCarryState3:
0E58 4002      1503       jc LessThanState3
0E5A 8002      1504       sjmp GreaterThanState3
0E5C           1505   LessThanState3:
0E5C 80BD      1506       sjmp State3
0E5E           1507   GreaterThanState3:
0E5E 120945    1508       lcall BeepSpeaker
0E61 0530      1509       inc STATE_VAR_1
0E63 753C14    1510       mov POWER, #20
0E66 753A00    1511       mov TIME, #0
0E69 80B0      1512       sjmp State3
0E6B           1513   State4:
0E6B 30F937    1514       jnb RESET_BUTTON, ResetToMainState4
0E6E 30B731    1515       jnb STOP_BUTTON, StopReflowState4
0E71 E530      1516       mov a, STATE_VAR_1
0E73 B40442    1517       cjne a, #4, State5
0E76 C0E0      1518            push acc
0E78 7401      1518            mov a, #1
0E7A 14        1518            dec a
0E7B 120208    1518            lcall ?Set_Cursor_1 ; Select column and row
0E7E D0E0      1518            pop acc
0E80 C083      1519            push dph
0E82 C082      1519            push dpl
0E84 C0E0      1519            push acc
0E86 9000E9    1519            mov dptr, #state4_message
0E89 1201FB    1519            lcall ?Send_Constant_String
0E8C D0E0      1519            pop acc
0E8E D082      1519            pop dpl
0E90 D083      1519            pop dph
0E92 120951    1520       lcall FSM2_Temp_Time_display
0E95 854E46    1521       mov TARGET_TIME, REFLOW_TIME_set
0E98 E53A      1522       mov a, TIME
0E9A C3        1523       clr c
0E9B 9546      1524       subb a, TARGET_TIME
0E9D 4009      1525       jc CheckCarryState4 ; C = 1, TIME < TARGET_TIME -> Keep Going
0E9F 020EAE    1526       ljmp GreaterThanState4 ; C = 0, TIME > TARGET_TIME -> Transition States
0EA2           1527   StopReflowState4:
0EA2 020F4A    1528       ljmp StopReflow
0EA5           1529   ResetToMainState4:
0EA5 020F41    1530       ljmp ResetToMain
0EA8           1531   CheckCarryState4:
0EA8 4002      1532       jc LessThanState4
0EAA 8002      1533       sjmp GreaterThanState4
0EAC           1534   LessThanState4:
0EAC 80BD      1535       sjmp State4 
0EAE           1536   GreaterThanState4:
0EAE 120945    1537       lcall BeepSpeaker
0EB1 0530      1538       inc STATE_VAR_1
0EB3 753C00    1539       mov POWER, #0
0EB6 80B3      1540       sjmp State4
0EB8           1541   State5:
0EB8 30F933    1542       jnb RESET_BUTTON, ResetToMainState5
0EBB 30B733    1543       jnb STOP_BUTTON, StopReflowState5
0EBE C280      1544       CLR p0.0 ;turn oven off
0EC0 E530      1545       mov a, STATE_VAR_1    
0EC2 B4052F    1546       cjne a, #5, State5toDone
0EC5 853E44    1547       mov TARGET, DEGREES60
0EC8 E535      1548       mov a, TEMP
0ECA C0E0      1549            push acc
0ECC 7401      1549            mov a, #1
0ECE 14        1549            dec a
0ECF 120208    1549            lcall ?Set_Cursor_1 ; Select column and row
0ED2 D0E0      1549            pop acc
0ED4 C083      1550            push dph
0ED6 C082      1550            push dpl
0ED8 C0E0      1550            push acc
0EDA 9000FA    1550            mov dptr, #state5_message
0EDD 1201FB    1550            lcall ?Send_Constant_String
0EE0 D0E0      1550            pop acc
0EE2 D082      1550            pop dpl
0EE4 D083      1550            pop dph
0EE6 120951    1551       lcall FSM2_Temp_Time_display
0EE9 B43C46    1552       cjne a, #60, CheckCarryState5
0EEC 80CA      1553       sjmp State5
0EEE           1554   
0EEE           1555   ResetToMainState5:
0EEE 020F41    1556       ljmp ResetToMain
0EF1           1557   
0EF1           1558   StopReflowState5:
0EF1 020F4A    1559       ljmp StopReflow
0EF4           1560       
0EF4           1561   State5toDone:
0EF4 120945    1562       lcall BeepSpeaker
0EF7 C0E0      1563            push acc
0EF9 7401      1563            mov a, #1
0EFB 14        1563            dec a
0EFC 120208    1563            lcall ?Set_Cursor_1 ; Select column and row
0EFF D0E0      1563            pop acc
0F01 C083      1564            push dph
0F03 C082      1564            push dpl
0F05 C0E0      1564            push acc
0F07 90012D    1564            mov dptr, #reflowdone_message
0F0A 1201FB    1564            lcall ?Send_Constant_String
0F0D D0E0      1564            pop acc
0F0F D082      1564            pop dpl
0F11 D083      1564            pop dph
0F13 C0E0      1565            push acc
0F15 7401      1565            mov a, #1
0F17 14        1565            dec a
0F18 120206    1565            lcall ?Set_Cursor_2 ; Select column and row
0F1B D0E0      1565            pop acc
0F1D C083      1566            push dph
0F1F C082      1566            push dpl
0F21 C0E0      1566            push acc
0F23 90013E    1566            mov dptr, #restart_message
0F26 1201FB    1566            lcall ?Send_Constant_String
0F29 D0E0      1566            pop acc
0F2B D082      1566            pop dpl
0F2D D083      1566            pop dph
0F2F 020FDF    1567       ljmp ReflowDone
0F32           1568   
0F32           1569   CheckCarryState5:
0F32 4002      1570       jc LessThanState5
0F34 8008      1571       sjmp GreaterThanState5
0F36           1572   LessThanState5:
0F36 753000    1573       mov STATE_VAR_1, #0
0F39 C200      1574       clr START_FLAG
0F3B 020EB8    1575       ljmp State5
0F3E           1576   GreaterThanState5:
0F3E 020EB8    1577       ljmp State5
0F41           1578   
0F41           1579   ResetToMain:
0F41 753000    1580       mov STATE_VAR_1, #0
0F44 753C00    1581       mov POWER, #0
0F47 0209E0    1582       ljmp MAIN
0F4A           1583   
0F4A           1584   StopReflow:
0F4A C0E0      1585            push acc
0F4C 7401      1585            mov a, #1
0F4E 14        1585            dec a
0F4F 120208    1585            lcall ?Set_Cursor_1 ; Select column and row
0F52 D0E0      1585            pop acc
0F54 C083      1586            push dph
0F56 C082      1586            push dpl
0F58 C0E0      1586            push acc
0F5A 90014F    1586            mov dptr, #stop_message
0F5D 1201FB    1586            lcall ?Send_Constant_String
0F60 D0E0      1586            pop acc
0F62 D082      1586            pop dpl
0F64 D083      1586            pop dph
0F66 C0E0      1587            push acc
0F68 7401      1587            mov a, #1
0F6A 14        1587            dec a
0F6B 120206    1587            lcall ?Set_Cursor_2 ; Select column and row
0F6E D0E0      1587            pop acc
0F70 C083      1588            push dph
0F72 C082      1588            push dpl
0F74 C0E0      1588            push acc
0F76 90013E    1588            mov dptr, #restart_message
0F79 1201FB    1588            lcall ?Send_Constant_String
0F7C D0E0      1588            pop acc
0F7E D082      1588            pop dpl
0F80 D083      1588            pop dph
0F82 C280      1589       clr P0.0 ; Turn power off
0F84           1590   ForeverStopped:
0F84 30F955    1591       jnb RESET_BUTTON, RestartProcess
0F87 80FB      1592       sjmp ForeverStopped
0F89           1593   
0F89           1594   STOPOVEN:
0F89 C0E0      1595            push acc
0F8B 7401      1595            mov a, #1
0F8D 14        1595            dec a
0F8E 120208    1595            lcall ?Set_Cursor_1 ; Select column and row
0F91 D0E0      1595            pop acc
0F93 C083      1596            push dph
0F95 C082      1596            push dpl
0F97 C0E0      1596            push acc
0F99 90010B    1596            mov dptr, #abortcondition_message
0F9C 1201FB    1596            lcall ?Send_Constant_String
0F9F D0E0      1596            pop acc
0FA1 D082      1596            pop dpl
0FA3 D083      1596            pop dph
0FA5 C0E0      1597            push acc
0FA7 7401      1597            mov a, #1
0FA9 14        1597            dec a
0FAA 120206    1597            lcall ?Set_Cursor_2 ; Select column and row
0FAD D0E0      1597            pop acc
0FAF C083      1598            push dph
0FB1 C082      1598            push dpl
0FB3 C0E0      1598            push acc
0FB5 90013E    1598            mov dptr, #restart_message
0FB8 1201FB    1598            lcall ?Send_Constant_String
0FBB D0E0      1598            pop acc
0FBD D082      1598            pop dpl
0FBF D083      1598            pop dph
0FC1 7C0A      1599       mov R4, #10
0FC3           1600   STOPOVENSpeakerLoop:
0FC3 120945    1601       lcall BeepSpeaker
0FC6 120689    1602       lcall Wait50ms
0FC9 120689    1603       lcall Wait50ms
0FCC 120689    1604       lcall Wait50ms
0FCF 120689    1605       lcall Wait50ms
0FD2 120689    1606       lcall Wait50ms
0FD5 DCEC      1607       djnz R4, STOPOVENSpeakerLoop
0FD7           1608   ForeverStop:
0FD7 30F902    1609       jnb RESET_BUTTON, RestartProcess
0FDA 80FB      1610       sjmp ForeverStop ; Infinite loop to stop the oven if abort condition is met
0FDC           1611   
0FDC           1612   RestartProcess:
0FDC 0209E0    1613       ljmp MAIN
0FDF           1614       
0FDF           1615   ReflowDone:
0FDF 7C05      1616       mov R4, #5
0FE1           1617   SpeakerLoop:
0FE1 120945    1618       lcall BeepSpeaker
0FE4 120689    1619       lcall Wait50ms
0FE7 120689    1620       lcall Wait50ms
0FEA 120689    1621       lcall Wait50ms
0FED 120689    1622       lcall Wait50ms
0FF0 120689    1623       lcall Wait50ms
0FF3 DCEC      1624       djnz R4, SpeakerLoop
0FF5           1625   Forever:
0FF5 30F902    1626       jnb RESET_BUTTON, ForeverToMain
0FF8 80FB      1627       sjmp Forever
0FFA           1628   ForeverToMain:
0FFA 020F41    1629            ljmp ResetToMain
0FFD           1630   END
